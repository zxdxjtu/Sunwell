<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI炉石传说卡牌生成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 30px;
        }

        .language-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .language-selector select:hover {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            padding: 30px;
        }

        .input-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1rem;
        }

        .form-group textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-upload-label {
            display: block;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .file-upload-label:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-upload-label.dragover {
            border-color: #667eea;
            background: #e8f2ff;
        }

        .generate-btn {
            width: 100%;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .card-preview {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .card-preview h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3rem;
        }

        #cardCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .example-prompts {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .example-prompts h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1rem;
        }

        .example-prompt {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: #e9ecef;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-prompt:hover {
            background: #667eea;
            color: white;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* 🎯 问题已通过源码修改永久解决，移除临时CSS修复 */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="language-selector">
                <select id="languageSelect" class="language-selector" onchange="changeLanguage(this.value)">
                    <option value="zh-CN">简体中文</option>
                    <option value="zh-TW">繁體中文</option>
                    <option value="en-US">English</option>
                    <option value="ja-JP">日本語</option>
                    <option value="ko-KR">한국어</option>
                </select>
            </div>
            <h1 data-i18n="title">🎮 AI炉石传说卡牌生成器</h1>
            <p data-i18n="subtitle">通过AI智能生成独特的炉石传说卡牌，支持文字描述和图片生成</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <div class="form-group">
                    <label for="cardPrompt" data-i18n="cardPromptLabel">📝 卡牌描述提示词</label>
                    <textarea 
                        id="cardPrompt" 
                        data-i18n-placeholder="cardPromptPlaceholder"
                    ></textarea>
                </div>

                <div class="example-prompts">
                    <h4 data-i18n="examplePromptsTitle">💡 示例提示词：</h4>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.shadowAssassin'))" data-i18n="examples.shadowAssassinButton">暗影刺客</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.ancientDragon'))" data-i18n="examples.ancientDragonButton">古老巨龙</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.healingPaladin'))" data-i18n="examples.healingPaladinButton">治疗圣骑士</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.demonSummon'))" data-i18n="examples.demonSummonButton">恶魔召唤物</button>
                </div>

                <div class="form-group">
                    <label for="cardImage" data-i18n="cardImageLabel">🖼️ 卡牌图片（可选）</label>
                    <div class="file-upload">
                        <input type="file" id="cardImage" accept="image/*">
                        <label for="cardImage" class="file-upload-label">
                            <div data-i18n="fileUploadText">📁 点击选择图片或拖拽到此处</div>
                            <div style="font-size: 0.9rem; color: #666; margin-top: 5px;" data-i18n="fileUploadHint">如果不上传图片，AI将自动生成炉石传说风格的图片</div>
                        </label>
                    </div>
                </div>

                <button id="generateBtn" class="generate-btn" onclick="generateAICard()" data-i18n="generateButton">
                    ✨ 生成AI卡牌
                </button>

                <div id="loading" class="loading">
                    <div class="spinner"></div>
                    <div id="loadingText" data-i18n="loadingText">正在生成卡牌...</div>
                </div>

                <div id="statusMessage" class="status-message" style="display: none;"></div>
            </div>

            <div class="card-preview">
                <h3 data-i18n="cardPreviewTitle">🎴 卡牌预览</h3>
                <canvas id="cardCanvas" width="400" height="560"></canvas>
                <div id="cardInfo" style="margin-top: 15px; text-align: left; font-size: 0.9rem; color: #666;"></div>
            </div>
        </div>
    </div>

    <!-- 加载必要的脚本 -->
    <script src="./prompts.js"></script>
<script src="./card-prompts.js"></script>

    <!-- 🚨 关键修复：在Sunwell加载前定义chars和LineBreaker函数 -->
    <script>
        // 🔧 修复：完整定义Sunwell需要的chars函数
        function chars(text) {
            if (!text || typeof text !== 'string') return [];
            return Array.from(text);
        }
        
        // chars.category函数 - Unicode字符分类
        chars.category = function(char) {
            if (!char || typeof char !== 'string') return 'P';
            
            const code = char.codePointAt(0);
            
            // CJK统一汉字
            if (code >= 0x4E00 && code <= 0x9FFF) return 'Lo';
            // CJK扩展A
            if (code >= 0x3400 && code <= 0x4DBF) return 'Lo';
            // CJK兼容汉字
            if (code >= 0xF900 && code <= 0xFAFF) return 'Lo';
            // 英文字母
            if ((code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A)) return 'L';
            // 数字
            if (code >= 0x30 && code <= 0x39) return 'N';
            // 空白字符
            if (/\s/.test(char)) return 'Z';
            // 标点符号
            if (/[，。！？；：""''（）【】《》]/.test(char)) return 'P';
            
            return 'P';
        };

        // LineBreaker函数
        window.LineBreaker = function(text) {
            this.text = text || '';
            this.pos = 0;
        };

        window.LineBreaker.prototype.nextBreak = function() {
            if (this.pos >= this.text.length) {
                return null;
            }
            
            const nextPos = this.pos + 1;
            const result = {
                position: nextPos,
                required: false
            };
            
            this.pos = nextPos;
            return result;
        };
        
        // 确保全局可访问
        window.chars = chars;
        if (typeof global === 'undefined') {
            var global = window;
        }
        global.chars = chars;
        
        console.log('🚨 在Sunwell加载前设置chars函数:', {
            'window.chars': typeof window.chars,
            'global.chars': typeof global.chars,
            'chars': typeof chars,
            '测试chars("test")': window.chars ? window.chars("test") : 'undefined'
        });
    </script>

<script src="./dist/sunwell.browser.js"></script>
<script src="./i18n/i18n.js?v=1.0.1"></script>
    <!-- 使用本地实现替代Google Generative AI -->
    
    <script>
        // 全局变量
        let sunwell = null;
        let currentCardData = null;
        
        // Gemini API配置 - 从环境变量或配置中获取
        const GEMINI_API_KEY = getApiKey();
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        
        // 获取API密钥的函数
        function getApiKey() {
            // 尝试从多个来源获取API密钥
            if (typeof process !== 'undefined' && process.env && process.env.GEMINI_API_KEY) {
                return process.env.GEMINI_API_KEY;
            }
            
            // 从localStorage获取（用户手动设置）
            const storedKey = localStorage.getItem('GEMINI_API_KEY');
            if (storedKey) {
                return storedKey;
            }
            
            // 从URL参数获取（开发测试用）
            const urlParams = new URLSearchParams(window.location.search);
            const urlKey = urlParams.get('api_key');
            if (urlKey) {
                return urlKey;
            }
            
            // 提示用户设置API密钥
            const userKey = prompt('请输入您的Gemini API密钥 (将保存到本地存储):');
            if (userKey) {
                localStorage.setItem('GEMINI_API_KEY', userKey);
                return userKey;
            }
            
            throw new Error('未找到Gemini API密钥，请设置环境变量GEMINI_API_KEY或手动输入');
        }
        
        // 调试日志函数
        function debugLog(message, data = null) {
            console.log(`🔍 ${message}`, data || '');
        }
        
        // 全局变量
        let uploadedImage = null;


        // 🔧 炉石传说关键词列表（中英文）
        const hearthstoneKeywords = [
            // 简体中文关键词
            '战吼', '亡语', '嘲讽', '冲锋', '潜行', '圣盾', '剧毒', '风怒', 
            '生命偷取', '法术伤害', '过载', '连击', '奥秘', '任务', '发现',
            '激励', '适应性', '招募', '回响', '磁力', '奇数', '偶数',
            // 繁体中文关键词
            '戰吼', '亡語', '嘲諷', '衝鋒', '潛行', '聖盾', '劇毒', '風怒',
            '生命偷取', '法術傷害', '過載', '連擊', '奧秘', '任務', '發現',
            '激勵', '適應性', '招募', '回響', '磁力', '奇數', '偶數',
            // 日语关键词（包含变体）
            '雄たけび', '雄叫び', '断末魔', '挑発', '突撃', '突進', '隠密', '聖なる盾', '猛毒', '疾風',
            '生命奪取', '呪文ダメージ', 'オーバーロード', 'コンボ', '秘策', 'クエスト', '発見',
            '鼓舞', '適応', '勧誘', 'エコー', 'マグネット', 'オーバーキル',
            // 韩语关键词
            '전투의 함성', '죽음의 메아리', '도발', '돌진', '은신', '성스러운 보호막', '맹독', '질풍',
            '생명력 흡수', '주문력', '과부하', '연계', '비밀', '퀘스트', '발견',
            '격려', '적응', '모집', '메아리', '자기력', '돌격', '과도한 살상',
            // 英文关键词
            'Battlecry', 'Deathrattle', 'Taunt', 'Charge', 'Stealth', 'Divine Shield', 
            'Poisonous', 'Windfury', 'Lifesteal', 'Spell Damage', 'Overload', 'Combo',
            'Secret', 'Quest', 'Discover', 'Inspire', 'Adapt', 'Recruit', 'Echo',
            'Magnetic', 'Rush', 'Overkill', 'Twinspell', 'Reborn'
        ];

        // 🛡️ 安全的关键词处理函数
        function safeProcessKeywords(text) {
            if (!text || typeof text !== 'string') {
                return { processedText: '', foundKeywords: [] };
            }
            
            let result = text;
            let foundKeywords = [];
            
            try {
                // 使用简单的字符串替换，避免复杂正则表达式
                hearthstoneKeywords.forEach(keyword => {
                    if (!keyword) return;
                    
                    // 🔧 支持中英文标点符号
                    const patterns = [
                        { search: keyword + '：', replace: `<b>${keyword}</b>：` }, // 中文冒号
                        { search: keyword + ':', replace: `<b>${keyword}</b>:` },   // 英文冒号
                        { search: keyword + ' ', replace: `<b>${keyword}</b> ` }    // 空格分隔
                    ];
                    
                    patterns.forEach(pattern => {
                        let lastResult = result;
                        result = result.split(pattern.search).join(pattern.replace);
                        
                        // 如果有替换，记录关键词
                        if (result !== lastResult && !foundKeywords.includes(keyword)) {
                            foundKeywords.push(keyword);
                        }
                    });
                });

                console.log('🔧 关键词处理完成:', { foundKeywords, processedText: result });
                return { processedText: result, foundKeywords };
                
            } catch (error) {
                console.error('❌ 关键词处理出错:', error);
                return { processedText: text, foundKeywords: [] };
            }
        }

        // 🛡️ 安全的文本分割函数（支持多语言）
        function safeTextSplit(text, maxWidth, fontSize) {
            if (!text || typeof text !== 'string') {
                return [''];
            }
            
            // 🔧 改进的语言检测（与上面保持一致）
            function detectSplitLanguage(text) {
                if (!text) return 'english';
                
                // 检测中文字符（简体、繁体）
                if (/[\u4e00-\u9fff]/.test(text)) return 'cjk';
                
                // 检测日文字符（平假名、片假名、汉字）  
                if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'cjk';
                
                // 检测韩文字符
                if (/[\uac00-\ud7af]/.test(text)) return 'cjk';
                
                // 默认为英文
                return 'english';
            }
            
            const textLanguage = detectSplitLanguage(text);
            
            if (textLanguage === 'cjk') {
                // CJK文本（中日韩）：基于字符数分行
                const targetCharsPerLine = 11;
                return safeChineseSplit(text, targetCharsPerLine, maxWidth, fontSize);
            } else {
                // 英文文本：基于单词分行
                return safeEnglishSplit(text, maxWidth, fontSize);
            }
        }
        
        // 🔧 新增：英文文本分行函数
        function safeEnglishSplit(text, maxWidth, fontSize) {
            console.log(`📏 英文分行: maxWidth=${maxWidth}, fontSize=${fontSize}`);
            console.log(`📏 英文原始文本: "${text}"`);
            
            const lines = [];
            const words = text.split(/\s+/); // 按空格分词
            let currentLine = '';
            
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine ? currentLine + ' ' + word : word;
                
                // 估算行长度（英文约35字符/行适合炉石卡牌）
                if (testLine.replace(/<\/?b>/g, '').length > 35 && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            console.log(`📏 英文分行完成，共${lines.length}行:`, lines);
            return lines.length > 0 ? lines : [''];
        }
        
        // 🔧 中文分行函数（保持原有逻辑）
        function safeChineseSplit(text, targetCharsPerLine, maxWidth, fontSize) {
            
            // 调试信息
            console.log(`📏 CJK分行参数: maxWidth=${maxWidth}, fontSize=${fontSize}, targetCharsPerLine=${targetCharsPerLine}`);
            console.log(`📏 原始文本: "${text}"`);
            console.log(`📏 文本中是否包含<b>标签:`, text.includes('<b>'));
            
            // 🔧 韩语文本处理：专门优化韩语字符密度
            const cleanTextLength = text.replace(/<\/?b>/g, '').length;
            let adjustedCharsPerLine = targetCharsPerLine;
            let maxLines = 4;
            
            // 检测是否为韩语文本
            const isKoreanText = /[가-힯]/.test(text);
            
            if (isKoreanText) {
                // 🔧 韩语专用参数：充分利用行空间，增加2-3字符容量
                if (cleanTextLength > 60) {
                    adjustedCharsPerLine = 14;  // 韩语超长文本：增加容量
                    maxLines = 5;
                } else if (cleanTextLength > 40) {
                    adjustedCharsPerLine = 15;  // 韩语中长文本：增加容量
                    maxLines = 4;
                } else {
                    adjustedCharsPerLine = 16;  // 韩语短文本：增加容量
                    maxLines = 3;
                }
                console.log(`📏 韩语文本检测(${cleanTextLength}字符)，调整参数: 每行${adjustedCharsPerLine}字，最多${maxLines}行`);
            } else {
                // 非韩语文本的原有逻辑
                if (cleanTextLength > 60) {
                    adjustedCharsPerLine = 8;
                    maxLines = 6;
                } else if (cleanTextLength > 40) {
                    adjustedCharsPerLine = 9;
                    maxLines = 5;
                }
                console.log(`📏 CJK非韩语文本(${cleanTextLength}字符)，调整参数: 每行${adjustedCharsPerLine}字，最多${maxLines}行`);
            }
            
            let lines = [];
            let currentLine = '';
            let i = 0;
            
            // 安全计数器
            const safeLimit = text.length + 50;
            let iterations = 0;
            
            while (i < text.length && lines.length < maxLines && iterations < safeLimit) {
                iterations++;
                
                // 🔧 修复：处理粗体标记及后续字符
                if (text.substr(i, 3) === '<b>') {
                    console.log(`📏 在分割中找到<b>标签在位置 ${i}`);
                    const endIndex = text.indexOf('</b>', i);
                    if (endIndex > i) {
                        const boldBlock = text.substring(i, endIndex + 4);
                        const boldText = text.substring(i + 3, endIndex);
                        console.log(`📏 分割中的粗体块: "${boldBlock}", 粗体文本: "${boldText}"`);
                        
                        // 🔧 关键修复：战吼等关键词后的冒号不应导致换行
                        let estimatedLength = boldText.length;
                        const nextCharIndex = endIndex + 4;
                        let nextChar = '';
                        if (nextCharIndex < text.length) {
                            nextChar = text[nextCharIndex];
                            if (/[：，。！？；]/.test(nextChar)) {
                                estimatedLength += 1; // 标点符号计入长度
                            }
                        }
                        
                        // 特殊处理：关键词+冒号的组合优先保持在同一行（支持多语言）
                        const isKeywordColon = /^(战吼|亡语|嘲讽|冲锋|潜行|圣盾|剧毒|风怒|生命偷取|法术伤害|过载|连击|奥秘|任务|发现|전투의 함성|죽음의 메아리|도발|돌진|은신|성스러운 보호막|맹독|질풍|생명력 흡수|주문력|과부하|연계|비밀|퀘스트|발견|Battlecry|Deathrattle|Taunt|Charge|Stealth|Divine Shield|Poisonous|Windfury|Lifesteal|Spell Damage|Overload|Combo)$/.test(boldText) && /[：:]/.test(nextChar);
                        
                        // 🔧 使用精确的长度检查：移除标签计算实际字符数
                        const currentEffectiveLength = currentLine.replace(/<\/?b>/g, '').length;
                        
                        if (currentEffectiveLength + estimatedLength > adjustedCharsPerLine && currentLine && !isKeywordColon) {
                            lines.push(currentLine);
                            currentLine = boldBlock;
                        } else {
                            currentLine += boldBlock;
                        }
                        i = endIndex + 4;
                        continue;
                    }
                }
                
                // 普通字符处理
                const char = text[i];
                
                // 🔧 特殊处理：冒号优先与前面内容保持在同一行
                const isColonAfterKeyword = char === '：' && currentLine.includes('</b>');
                
                // 🔧 韩语智能换行：考虑标点符号和语义分割
                const effectiveLength = currentLine.replace(/<\/?b>/g, '').length;
                
                // 韩语智能换行：在句号、逗号后优先换行，避免行首出现标点
                const nextChar = i + 1 < text.length ? text[i + 1] : '';
                const isKoreanPunctuation = /[.,;!?]/.test(char);
                const shouldBreakAfterPunctuation = isKoreanText && isKoreanPunctuation && effectiveLength >= adjustedCharsPerLine * 0.7;
                const isGoodBreakPoint = shouldBreakAfterPunctuation && /\s/.test(nextChar);
                
                // 韩语特殊处理：避免过短的单词独占一行
                const isShortWord = isKoreanText && effectiveLength < adjustedCharsPerLine * 0.5;
                const shouldAvoidEarlyBreak = isShortWord && !/[.,!?]/.test(char);
                
                if ((effectiveLength >= adjustedCharsPerLine && currentLine && !isColonAfterKeyword && !shouldAvoidEarlyBreak) || isGoodBreakPoint) {
                    // 韩语特殊处理：标点符号和其后的空格一起保留在当前行
                    if (isGoodBreakPoint) {
                        currentLine += char;
                        if (/\s/.test(nextChar)) {
                            i++; // 跳过后面的空格
                            currentLine += ' ';
                        }
                    }
                    lines.push(currentLine);
                    currentLine = isGoodBreakPoint ? '' : char;
                } else {
                    currentLine += char;
                }
                i++;
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // 🔧 韩语标点符号处理：避免标点符号单独成行
            if (isKoreanText && lines.length > 0) {
                const processedLines = [];
                for (let j = 0; j < lines.length; j++) {
                    const line = lines[j].trim();
                    const cleanLine = line.replace(/<\/?b>/g, '');
                    
                    // 检查是否是单独的标点符号行
                    const isPunctuationOnlyLine = /^[.,!?;:]+$/.test(cleanLine);
                    
                    if (isPunctuationOnlyLine && processedLines.length > 0) {
                        // 将标点符号合并到前一行
                        processedLines[processedLines.length - 1] += line;
                        console.log(`📏 韩语标点合并: 将"${line}"合并到前一行`);
                    } else if (cleanLine.length <= 3 && processedLines.length > 0) {
                        // 超短行（3字符以下）也尝试合并到前一行
                        const prevLine = processedLines[processedLines.length - 1];
                        const prevCleanLine = prevLine.replace(/<\/?b>/g, '');
                        if (prevCleanLine.length + cleanLine.length <= adjustedCharsPerLine) {
                            processedLines[processedLines.length - 1] += ' ' + line;
                            console.log(`📏 韩语短行合并: 将"${line}"合并到前一行`);
                        } else {
                            processedLines.push(line);
                        }
                    } else {
                        processedLines.push(line);
                    }
                }
                lines = processedLines;
                console.log(`📏 韩语标点处理后行数: ${lines.length}`);
            }
            
            // 🔧 韩语长文本处理：如果行数仍然过多，合并短行避免Canvas错误
            if (lines.length > 4) {
                console.log(`📏 ⚠️ 行数过多(${lines.length})，尝试合并短行避免Canvas错误`);
                const mergedLines = [];
                let tempLine = '';
                
                for (let j = 0; j < lines.length; j++) {
                    const line = lines[j];
                    const cleanLine = line.replace(/<\/?b>/g, '');
                    
                    if (tempLine && (tempLine.replace(/<\/?b>/g, '').length + cleanLine.length <= adjustedCharsPerLine + 2)) {
                        tempLine += line;
                    } else {
                        if (tempLine) mergedLines.push(tempLine);
                        tempLine = line;
                    }
                }
                if (tempLine) mergedLines.push(tempLine);
                
                // 只取前4行避免Canvas错误
                const finalLines = mergedLines.slice(0, 4);
                console.log(`📏 合并后行数: ${finalLines.length}`);
                
                finalLines.forEach((line, index) => {
                    console.log(`📏 合并后第${index}行: "${line}"`);
                });
                
                return finalLines;
            }
            
            console.log(`📏 CJK文本分割完成，共${lines.length}行:`);
            lines.forEach((line, index) => {
                console.log(`📏 第${index}行: "${line}"`);
                console.log(`📏 第${index}行包含<b>标签:`, line.includes('<b>'));
            });
            
            return lines.length > 0 ? lines : [''];
        }

        // 🛡️ 安全的中文文本渲染
        function safeRenderChineseText(canvas, textConfig) {
            if (!canvas || !textConfig) return;
            
            const ctx = canvas.getContext('2d');
            const { text, fontSize = 20, lines, keywords = [], isPremium = false } = textConfig;
            
            try {
                // 🔧 新功能：根据卡牌类型动态调整文字颜色和描边
                // 金色传说/史诗：白色文字 + 深色描边，普通卡牌：黑色文字无描边
                const textColor = isPremium ? '#FFFFFF' : '#000000';
                const useStroke = isPremium; // 金色卡牌使用描边增强可读性
                
                ctx.fillStyle = textColor;
                if (useStroke) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; // 半透明黑色描边
                    ctx.lineWidth = 1.5; // 轻微描边
                }
                ctx.textAlign = 'left';
                ctx.textBaseline = 'ideographic';
                
                console.log(`🎨 文字设置: isPremium=${isPremium}, textColor=${textColor}, stroke=${useStroke}`);
                
                
                const baseX = 88;
                const baseY = 385;
                const lineHeight = Math.round(fontSize * 1.3);
                
                console.log('🔍 safeRenderChineseText 开始渲染，总行数:', lines.length);
                console.log('🔍 所有行内容:', lines);
                
                lines.forEach((line, lineIndex) => {
                    if (lineIndex >= 6) return; // 最多6行保护
                    
                    console.log(`🔍 处理第${lineIndex}行: "${line}"`);
                    console.log(`🔍 行中是否包含<b>标签:`, line.includes('<b>'));
                    
                    let currentX = baseX;
                    const y = baseY + fontSize + (lineIndex * lineHeight);
                    
                    // 应用缩进
                    if (lineIndex === 2) currentX += 38;
                    if (lineIndex === 3) currentX += 40;
                    
                    let i = 0;
                    const safeLimit = line.length + 10;
                    let iterations = 0;
                    
                    while (i < line.length && iterations < safeLimit) {
                        iterations++;
                        
                        if (line.substr(i, 3) === '<b>') {
                            console.log(`🔍 找到<b>标签在位置 ${i}`);
                            const endIndex = line.indexOf('</b>', i);
                            console.log(`🔍 找到</b>标签在位置 ${endIndex}`);
                            if (endIndex > i) {
                                const boldText = line.substring(i + 3, endIndex);
                                console.log(`🔍 提取粗体文本: "${boldText}"`);
                                
                                // 设置粗体（使用与当前上下文相同的颜色）
                                ctx.font = `bold ${fontSize}px "经典隶变简", Arial, sans-serif`;
                                ctx.fillStyle = textColor; // 确保粗体使用正确颜色
                                
                                // 先绘制描边（如果需要），再绘制填充
                                if (useStroke) {
                                    ctx.strokeText(boldText, currentX, y);
                                }
                                ctx.fillText(boldText, currentX, y);
                                currentX += ctx.measureText(boldText).width;
                                
                                console.log(`🔍 粗体文本已渲染，跳转到位置 ${endIndex + 4}`);
                                i = endIndex + 4;
                                continue;
                            } else {
                                console.log(`🔍 ⚠️ 没有找到匹配的</b>标签`);
                            }
                        }
                        
                        // 普通字符
                        const char = line[i];
                        console.log(`🔍 渲染普通字符: "${char}" 在位置 ${i}`);
                        ctx.font = `${fontSize}px "经典隶变简", Arial, sans-serif`;
                        ctx.fillStyle = textColor; // 确保普通字符使用正确颜色
                        
                        // 先绘制描边（如果需要），再绘制填充
                        if (useStroke) {
                            ctx.strokeText(char, currentX, y);
                        }
                        ctx.fillText(char, currentX, y);
                        currentX += ctx.measureText(char).width;
                        i++;
                    }
                });
                
                console.log(`✅ 中文文本渲染成功: ${lines.length}行`);
                
            } catch (error) {
                console.error('❌ 中文文本渲染失败:', error);
                throw error;
            }
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });

        // 初始化页面
        async function initializePage() {
            if (window.location.search.includes('debug=true')) {
                console.log('🚀 初始化AI卡牌生成器页面');
            }
            
            // 初始化国际化系统
            await initializeI18n();
            
            // 初始化Sunwell
            initializeSunwell();
            
            // 设置文件上传拖拽功能
            setupFileUpload();
            
            // 显示初始状态
            showStatus(i18n.t('status.ready'), 'info');
        }

        // 初始化国际化系统
        async function initializeI18n() {
            try {
                // 确保i18n对象已加载
                if (typeof i18n === 'undefined') {
                    throw new Error('i18n对象未定义，请检查i18n.js是否正确加载');
                }
                
                await i18n.init();
                
                // 设置语言选择器的当前值
                const languageSelect = document.getElementById('languageSelect');
                languageSelect.value = i18n.currentLanguage;
                
                // 监听语言切换事件
                i18n.on('languageChanged', function(language) {
                    console.log('语言已切换到:', language);
                    
                    // 更新页面翻译
                    i18n.updatePageTranslations();
                    
                    // 重新初始化Sunwell以应用新的字体配置
                    if (sunwell) {
                        const getFontConfig = () => {
                            const currentLang = i18n.getCurrentLanguage();
                            
                            // 多语言字体配置
                            const fontConfigs = {
                                'zh-CN': {
                                    titleFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "Arial Unicode MS", sans-serif'
                                },
                                'zh-TW': {
                                    titleFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft JhengHei", "PingFang TC", "Arial Unicode MS", sans-serif'
                                },
                                'ja-JP': {
                                    titleFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    bodyFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    gemFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", sans-serif'
                                },
                                'ko-KR': {
                                    titleFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    bodyFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    gemFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", sans-serif'
                                },
                                'en-US': {
                                    titleFont: 'Belwe, "Times New Roman", "Georgia", serif',
                                    bodyFont: '"Franklin Gothic Condensed", "Arial", "Helvetica", "Tahoma", sans-serif',
                                    gemFont: 'Belwe, "Times New Roman", "Georgia", serif'
                                }
                            };
                            
                            return fontConfigs[currentLang] || fontConfigs['en-US'];
                        };
                        
                        const fontConfig = getFontConfig();
                        
                        // 根据语言设置字体大小 - 调整英文字体以适配卡牌
                        const currentLang = i18n.getCurrentLanguage();
                        let bodyFontSize = 28;  // 🔧 修复：英文使用28px，避免文本过大乱码
                        let bodyLineHeight = 32;  // 相应调整行高
                        
                        // 🔧 语言路由系统：英文使用Sunwell原生方案，中文/其他语言使用外置文本框
                        const isEnglish = currentLang === 'en-US';
                        console.log(`🔍 语言路由检测: ${currentLang}, 是否英文: ${isEnglish}`);
                        
                        if (isEnglish) {
                            // 🎯 英文模式：使用修复后的配置，确保文本渲染正确
                            console.log('🎨 英文模式：使用修复后的Sunwell配置');
                            sunwell = new Sunwell({
                                assetFolder: './assets/',
                                // 🔧 应用修复方案中的字体配置
                                titleFont: "Belwe, Arial, sans-serif",
                                bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                                bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                                bodyFontSize: 38,
                                bodyLineHeight: 40,
                                bodyFontOffset: {x: 0, y: 30}, // 修复后的垂直位置
                                drawTimeout: 20000,
                                debug: false
                            });
                        } else {
                            // 🎯 中文/其他语言模式：隐藏Sunwell文本，使用外置文本框
                            console.log('🎨 中文/其他语言模式：使用外置文本框方案');
                            sunwell = new Sunwell({
                                titleFont: "Arial, sans-serif",
                                bodyFontRegular: "Arial, sans-serif",
                                bodyFontItalic: "Arial, sans-serif",  
                                bodyFontBold: "Arial, sans-serif",
                                bodyFontBoldItalic: "Arial, sans-serif",
                                bodyFontSize: 1,  // 隐藏Sunwell文本
                                bodyLineHeight: 1,  
                                bodyFontOffset: {x: -9999, y: -9999},  // 移除屏幕外
                                gemFont: "Arial, sans-serif",
                                nameFont: "Arial, sans-serif",
                                assetFolder: './assets/',
                                drawTimeout: 20000,
                                debug: false
                            });
                        }
                        
                        console.log(`🔧 Sunwell路由配置完成: ${isEnglish ? '英文原生模式' : '中文外置文本框模式'}`);                        
                        
                        // 重新生成卡牌以应用新语言和字体
                        if (currentCardData) {
                            renderCard(currentCardData);
                        }
                    }
                });
                
                console.log('✅ 国际化系统初始化完成');
            } catch (error) {
                console.error('❌ 国际化系统初始化失败:', error);
            }
        }

        // 语言切换函数
        async function changeLanguage(language) {
            try {
                const success = await i18n.switchLanguage(language);
                if (success) {
                    showStatus(i18n.t('status.languageChanged'), 'success');
                } else {
                    showStatus('语言切换失败', 'error');
                }
            } catch (error) {
                console.error('语言切换失败:', error);
                showStatus('语言切换失败', 'error');
            }
        }

        // 初始化Sunwell库
        function initializeSunwell() {
            try {
                if (window.location.search.includes('debug=true')) {
                    console.log('🎨 初始化Sunwell渲染引擎');
                }
                
                // 等待Sunwell库加载完成
                const checkSunwell = setInterval(() => {
                    if (typeof Sunwell !== 'undefined') {
                        clearInterval(checkSunwell);
                        
                        // 🚨 重新确保chars函数在Sunwell加载后仍可用
                        if (typeof window.chars === 'undefined' || typeof chars === 'undefined') {
                            console.error('🚨 警告：Sunwell加载后chars函数丢失！重新设置...');
                            // 重新设置chars函数（从上面复制）
                            const charsFunc = function(text) {
                                if (!text || typeof text !== 'string') return [];
                                return Array.from(text);
                            };
                            charsFunc.category = function(char) {
                                if (!char || typeof char !== 'string') return 'P';
                                const code = char.codePointAt(0);
                                if (code >= 0x4E00 && code <= 0x9FFF) return 'Lo';
                                if (code >= 0x3400 && code <= 0x4DBF) return 'Lo';
                                if (code >= 0xF900 && code <= 0xFAFF) return 'Lo';
                                if ((code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A)) return 'L';
                                if (code >= 0x30 && code <= 0x39) return 'N';
                                if (/\s/.test(char)) return 'Z';
                                if (/[，。！？；：""''（）【】《》]/.test(char)) return 'P';
                                return 'P';
                            };
                            
                            window.chars = charsFunc;
                            global.chars = charsFunc;
                            console.log('🚨 chars函数重新设置完成');
                        }
                        
                        // 根据当前语言选择合适的字体
                        const getFontConfig = () => {
                            const currentLang = i18n.getCurrentLanguage();
                            
                            // 多语言字体配置
                            const fontConfigs = {
                                'zh-CN': {
                                    titleFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "Arial Unicode MS", sans-serif'
                                },
                                'zh-TW': {
                                    titleFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft JhengHei", "PingFang TC", "Arial Unicode MS", sans-serif'
                                },
                                'ja-JP': {
                                    titleFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    bodyFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    gemFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", sans-serif'
                                },
                                'ko-KR': {
                                    titleFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    bodyFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    gemFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", sans-serif'
                                },
                                'en-US': {
                                    titleFont: 'Belwe, "Times New Roman", "Georgia", serif',
                                    bodyFont: '"Franklin Gothic Condensed", "Arial", "Helvetica", "Tahoma", sans-serif',
                                    gemFont: 'Belwe, "Times New Roman", "Georgia", serif'
                                }
                            };
                            
                            return fontConfigs[currentLang] || fontConfigs['en-US'];
                        };
                        
                        const fontConfig = getFontConfig();
                        
                        // 根据语言设置字体大小 - 调整英文字体以适配卡牌
                        const currentLang = i18n.getCurrentLanguage();
                        let bodyFontSize = 28;  // 🔧 修复：英文使用28px，避免文本过大乱码
                        let bodyLineHeight = 32;  // 相应调整行高
                        
                        // 为日语设置更大的字体大小以提高可读性
                        if (currentLang === 'ja-JP') {
                            bodyFontSize = 72;  // 从48增大到72
                            bodyLineHeight = 80;  // 相应调整行高
                        }
                        
                        // 根据语言调整字体偏移量
                        let bodyFontOffset = {x: 0, y: 8};
                        if (currentLang === 'ja-JP') {
                            bodyFontOffset = {x: 0, y: 10}; // 日语字体稍微向下偏移以改善显示
                        }
                        
                        // 🔧 语言路由系统(第二处)：英文使用Sunwell原生方案，中文/其他语言使用外置文本框
                        const isEnglish = currentLang === 'en-US';
                        console.log(`🔍 语言路由检测(第二处): ${currentLang}, 是否英文: ${isEnglish}`);
                        
                        if (isEnglish) {
                            // 🎯 英文模式：使用修复后的配置，确保文本渲染正确
                            console.log('🎨 英文模式(第二处)：使用修复后的Sunwell配置');
                            sunwell = new Sunwell({
                                assetFolder: './assets/',
                                // 🔧 应用修复方案中的字体配置
                                titleFont: "Belwe, Arial, sans-serif",
                                bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                                bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                                bodyFontSize: 38,
                                bodyLineHeight: 40,
                                bodyFontOffset: {x: 0, y: 30}, // 修复后的垂直位置
                                drawTimeout: 20000,
                                debug: false
                            });
                        } else {
                            // 🎯 中文/其他语言模式：隐藏Sunwell文本，使用外置文本框
                            console.log('🎨 中文/其他语言模式(第二处)：使用外置文本框方案');
                            sunwell = new Sunwell({
                                titleFont: "Arial, sans-serif",
                                bodyFontRegular: "Arial, sans-serif",
                                bodyFontItalic: "Arial, sans-serif",  
                                bodyFontBold: "Arial, sans-serif",
                                bodyFontBoldItalic: "Arial, sans-serif",
                                bodyFontSize: 1,  // 隐藏Sunwell文本
                                bodyLineHeight: 1,  
                                bodyFontOffset: {x: -9999, y: -9999},  // 移除屏幕外
                                gemFont: "Arial, sans-serif",
                                nameFont: "Arial, sans-serif",
                                assetFolder: './assets/',
                                drawTimeout: 20000,
                                debug: false
                            });
                        }
                        
                        console.log(`🔧 Sunwell路由配置完成(第二处): ${isEnglish ? '英文原生模式' : '中文外置文本框模式'}`);
                        
                        // Sunwell已通过构造函数配置，无需额外设置
                        if (window.location.search.includes('debug=true')) {
                            console.log('✅ Sunwell配置完成');
                            console.log('✅ Sunwell初始化成功');
                        }
                        showStatus('Sunwell渲染引擎已就绪', 'success');
                    }
                }, 100);
                
                // 超时检查
                setTimeout(() => {
                    if (!sunwell) {
                        console.error('❌ Sunwell初始化超时');
                        showStatus('渲染引擎初始化失败，请刷新页面重试', 'error');
                    }
                }, 10000);
                
            } catch (error) {
                console.error('❌ Sunwell初始化失败:', error);
                showStatus('渲染引擎初始化失败: ' + error.message, 'error');
            }
        }

        // 设置文件上传拖拽功能
        function setupFileUpload() {
            const fileUpload = document.querySelector('.file-upload-label');
            const fileInput = document.getElementById('cardImage');

            // 拖拽事件
            fileUpload.addEventListener('dragover', function(e) {
                e.preventDefault();
                fileUpload.classList.add('dragover');
            });

            fileUpload.addEventListener('dragleave', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
            });

            fileUpload.addEventListener('drop', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handleFileSelect(files[0]);
                }
            });

            // 文件选择事件
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0]);
                }
            });
        }

        // 处理文件选择
        function handleFileSelect(file) {
            if (file && file.type.startsWith('image/')) {
                if (window.location.search.includes('debug=true')) {
                    console.log('📁 用户上传图片:', file.name);
                }
                
                // 读取文件并设置uploadedImage变量
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedImage = e.target.result;
                    if (window.location.search.includes('debug=true')) {
                        console.log('✅ 图片已读取并设置为uploadedImage');
                    }
                    showStatus(`已选择图片: ${file.name}，将使用上传的图片`, 'success');
                };
                reader.onerror = function() {
                    showStatus('图片读取失败，请重新选择', 'error');
                };
                reader.readAsDataURL(file);
            } else {
                showStatus('请选择有效的图片文件', 'error');
            }
        }

        // 设置示例提示词
        function setPrompt(prompt) {
            document.getElementById('cardPrompt').value = prompt;
            showStatus(i18n.t('status.promptSet'), 'info');
        }

        // 显示状态消息
        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;
            statusElement.style.display = 'block';
            
            // 3秒后自动隐藏成功和信息消息
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);
            }
        }
        
        // 更新状态的别名函数
        function updateStatus(message, type = 'info') {
            showStatus(message, type);
        }
        
        // 解析AI生成的卡牌信息
        function parseCardInfo(aiResponse) {
            if (window.location.search.includes('debug=true')) {
                console.log('🔍 开始解析AI响应');
            }
            
            try {
                // 尝试解析JSON格式的响应
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    if (window.location.search.includes('debug=true')) {
                        console.log('✅ JSON解析成功:', parsed);
                    }
                    return parsed;
                }
                
                // 如果不是JSON格式，使用正则表达式提取信息
                const cardInfo = {
                    name: extractValue(aiResponse, ['名称', 'name', '卡牌名称', 'カード名', '名前']) || '神秘生物',
                    cost: parseInt(extractValue(aiResponse, ['费用', 'cost', '法力值', 'コスト', 'マナコスト'])) || 3,
                    attack: parseInt(extractValue(aiResponse, ['攻击', 'attack', '攻击力', '攻撃力', '攻撃'])) || 2,
                    health: parseInt(extractValue(aiResponse, ['生命', 'health', '生命值', '体力', '生命値'])) || 3,
                    text: extractValue(aiResponse, ['描述', 'description', '效果', 'text', '説明', 'テキスト']) || '',
                    cardClass: extractValue(aiResponse, ['职业', 'class', '英雄职业', 'クラス', '職業']) || 'NEUTRAL',
                    race: extractValue(aiResponse, ['种族', 'race', '生物类型', '種族', 'レース']) || '',
                    rarity: extractValue(aiResponse, ['稀有度', 'rarity', 'レアリティ', '希少度']) || 'COMMON'
                };
                
                if (window.location.search.includes('debug=true')) {
                    console.log('✅ 解析结果:', cardInfo);
                }
                return cardInfo;
            } catch (error) {
                console.error('解析卡牌信息失败:', error);
                if (window.location.search.includes('debug=true')) {
                    console.log('⚠️ 解析失败，使用默认值');
                }
                return {
                    name: '神秘生物',
                    cost: 3,
                    attack: 2,
                    health: 3,
                    text: '一个神秘的生物。',
                    cardClass: 'NEUTRAL',
                    race: '',
                    rarity: 'COMMON'
                };
            }
        }
        
        // 提取值的辅助函数
        function extractValue(text, keys) {
            for (const key of keys) {
                const regex = new RegExp(`${key}[：:：]?\\s*([^\\n,，]+)`, 'i');
                const match = text.match(regex);
                if (match) {
                    return match[1].trim();
                }
            }
            return null;
        }

        // 显示/隐藏加载状态
        function showLoading(show, textKey = 'status.generating') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            const generateBtn = document.getElementById('generateBtn');
            
            if (show) {
                loading.classList.add('show');
                loadingText.textContent = i18n.t(textKey);
                generateBtn.disabled = true;
            } else {
                loading.classList.remove('show');
                generateBtn.disabled = false;
            }
        }

        // 主要的卡牌生成函数
        async function generateCard() {
            const prompt = document.getElementById('cardPrompt').value.trim();
            const imageFile = document.getElementById('cardImage').files[0];
            
            if (!prompt) {
                showStatus(i18n.t('errors.noPrompt'), 'error');
                return;
            }
            
            if (!sunwell) {
                showStatus(i18n.t('errors.engineNotReady'), 'error');
                return;
            }
            
            try {
                showLoading(true, 'status.analyzingPrompt');
                if (window.location.search.includes('debug=true')) {
                    console.log('🤖 开始AI卡牌生成流程');
                    console.log('📝 用户提示词:', prompt);
                }
                
                // 步骤1: 解析卡牌属性
                showLoading(true, 'status.parsingAttributes');
                const cardAttributes = await generateCardAttributes(prompt);
                if (window.location.search.includes('debug=true')) {
                    console.log('📊 解析的卡牌属性:', cardAttributes);
                }
                
                // 步骤2: 生成或处理图片
                let cardImageUrl = null;
                if (imageFile) {
                    showLoading(true, 'status.processingImage');
                    cardImageUrl = await processUploadedImage(imageFile);
                } else {
                    showLoading(true, 'status.generatingImage');
                    cardImageUrl = await generateCardImage(cardAttributes);
                }
                
                // 步骤3: 渲染卡牌
                showLoading(true, 'status.renderingCard');
                await renderCard(cardAttributes, cardImageUrl);
                
                showLoading(false);
                showStatus(i18n.t('status.generateSuccess'), 'success');
                
            } catch (error) {
                console.error('❌ 卡牌生成失败:', error);
                showLoading(false);
                showStatus(i18n.t('errors.generateFailed') + ': ' + error.message, 'error');
            }
        }



        // 生成AI卡牌的主函数
        async function generateAICard() {
            const prompt = document.getElementById('cardPrompt').value.trim();
            if (!prompt) {
                showStatus(i18n.t('errors.noPrompt'), 'error');
                return;
            }

            if (window.location.search.includes('debug=true')) {
                console.log('🤖 开始生成AI卡牌，提示词:', prompt);
            }
            showLoading(true);
            showStatus(i18n.t('status.generatingAI'), 'info');

            try {
                // 1. 生成卡牌属性
                const cardAttributes = await generateCardAttributes(prompt);
                
                // 2. 生成或使用上传的图片
                let imageUrl;
                if (uploadedImage) {
                    imageUrl = uploadedImage;
                } else {
                    imageUrl = await generateAIImage(cardAttributes.name || prompt);
                }
                
                // 3. 渲染卡牌
                await renderCard(cardAttributes, imageUrl);
                
                showStatus(i18n.t('status.aiGenerateComplete'), 'success');
            } catch (error) {
                console.error('生成AI卡牌失败:', error);

                showStatus(i18n.t('errors.generateFailed') + ': ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // 生成卡牌属性
        async function generateCardAttributes(prompt) {
            showStatus(i18n.t('status.analyzingAttributes'), 'info');
            
            // 获取当前语言的系统提示词
            const currentLanguage = i18n.getCurrentLanguage();
            const systemPrompt = CardPrompts.getCardPrompt(currentLanguage);

            try {
                // 🔧 检查网络连接
                console.log('🌐 尝试连接Gemini API...');
                
                const requestBody = {
                    contents: [{
                        parts: [{
                            text: systemPrompt + '\n\n用户描述: ' + prompt
                        }]
                    }]
                };
                
                // 🔧 添加超时和重试机制
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时
                
                const response = await fetch(GEMINI_API_URL + '?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API响应错误:', response.status, errorText);
                    throw new Error(`API请求失败: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('✅ API响应成功:', data);
                
                const aiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!aiResponse) {
                    throw new Error('API返回空响应');
                }
                
                const cardInfo = parseCardInfo(aiResponse);
                return cardInfo;
                
            } catch (error) {
                console.error('❌ 生成卡牌属性失败:', error);
                
                // 🔧 提供备用方案：本地示例卡牌
                if (error.name === 'AbortError') {
                    console.log('🔧 API超时，使用本地备用卡牌');
                    return generateFallbackCard(prompt, currentLanguage);
                } else if (error.message.includes('Failed to fetch')) {
                    console.log('🔧 网络连接失败，使用本地备用卡牌');
                    return generateFallbackCard(prompt, currentLanguage);
                } else {
                    throw new Error(i18n.t('errors.aiServiceUnavailable') + ': ' + error.message);
                }
            }
        }
        
        // 🔧 备用卡牌生成函数
        function generateFallbackCard(prompt, language = 'ko-KR') {
            console.log('🎯 生成本地备用卡牌，语言:', language);
            
            // 根据语言生成不同的示例卡牌
            const fallbackCards = {
                'ko-KR': {
                    name: '지옥의 발톱',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>전투의 함성</b>: 적 영웅에게 2의 피해를 줍니다. 이 하수인이 죽으면, 적 영웅에게 1의 피해를 줍니다.',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'zh-CN': {
                    name: '地狱爪牙',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>战吼</b>：对敌方英雄造成2点伤害。该随从死亡时，对敌方英雄造成1点伤害。',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'zh-TW': {
                    name: '地獄爪牙',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>戰吼</b>：對敵方英雄造成2點傷害。該隨從死亡時，對敵方英雄造成1點傷害。',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'ja-JP': {
                    name: '地獄の爪牙',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>雄叫び</b>：敵ヒーローに2ダメージ。このミニオンが死亡した時、敵ヒーローに1ダメージ。',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'en-US': {
                    name: 'Infernal Minion',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>Battlecry:</b> Deal 2 damage to the enemy hero. <b>Deathrattle:</b> Deal 1 damage to the enemy hero.',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                }
            };
            
            const fallbackCard = fallbackCards[language] || fallbackCards['en-US'];
            console.log('✅ 生成备用卡牌:', fallbackCard);
            showStatus(`🔧 网络连接失败，使用本地示例卡牌: ${fallbackCard.name}`, 'info');
            
            return fallbackCard;
        }

        // 生成AI图片的函数（使用Gemini图片生成模型）
        async function generateAIImage(prompt) {
            updateStatus(i18n.t('status.generatingAIImage'), 'info');
            
            try {
                // 使用prompts.js生成原画提示词（不包含卡牌样式）
                const imagePrompt = ImagePrompts.generateArtworkPrompt(prompt, '');
                
                if (window.location.search.includes('debug=true')) {
                    console.log('🎨 图片生成提示词:', imagePrompt);
                }
                
                // 调用Gemini图片生成API
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: imagePrompt
                            }]
                        }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE']
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Gemini图片生成API请求失败: ${response.status}`);
                }
                
                const data = await response.json();
                if (window.location.search.includes('debug=true')) {
                     console.log('🖼️ Gemini图片生成API响应:', data);
                 }
                
                // 查找图片数据
                let imageData = null;
                const candidate = data.candidates?.[0];
                if (candidate && candidate.content && candidate.content.parts) {
                    for (const part of candidate.content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            imageData = part.inlineData.data;
                            break;
                        }
                    }
                }
                
                if (!imageData) {
                    throw new Error('未找到生成的图片数据');
                }
                
                // 将base64数据转换为data URL
                const imageUrl = `data:image/png;base64,${imageData}`;
                if (window.location.search.includes('debug=true')) {
                     console.log('🖼️ 生成的图片Data URL长度:', imageUrl.length);
                 }
                
                // 验证图片是否有效
                const img = new Image();
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        if (window.location.search.includes('debug=true')) {
                            console.log('✅ Gemini生成的AI图片加载成功');
                        }
                        updateStatus(i18n.t('status.aiImageComplete'), 'success');
                        resolve(imageUrl);
                    };
                    img.onerror = () => {
                        if (window.location.search.includes('debug=true')) {
                            console.log('❌ Gemini生成的AI图片加载失败');
                        }
                        updateStatus(i18n.t('errors.aiImageLoadFailed'), 'error');
                        reject(new Error(i18n.t('errors.invalidImage')));
                    };
                    img.src = imageUrl;
                });
                
            } catch (error) {
                console.error('❌ 生成AI图片失败:', error);
                updateStatus(i18n.t('errors.aiImageGenerateFailed') + ': ' + error.message, 'error');
                return null;
            }
        }
        
        // 生成卡牌图片（使用Gemini图片生成模型）
        async function generateCardImage(cardAttributes) {
            if (window.location.search.includes('debug=true')) {
                console.log('🎨 使用Gemini生成炉石传说风格图片');
            }
            
            // 使用prompts.js根据卡牌类型生成原画提示词
            const imagePrompt = ImagePrompts.getPromptByType(cardAttributes.name, cardAttributes.text, cardAttributes.type || 'MINION');
            
            try {
                // 调用Gemini图片生成API
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: imagePrompt
                            }]
                        }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE']
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Gemini图片生成API请求失败: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('🖼️ Gemini图片生成API响应:', data);
                
                // 查找图片数据
                let imageData = null;
                const candidate = data.candidates?.[0];
                if (candidate && candidate.content && candidate.content.parts) {
                    for (const part of candidate.content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            imageData = part.inlineData.data;
                            break;
                        }
                    }
                }
                
                if (!imageData) {
                    throw new Error('未找到生成的图片数据');
                }
                
                // 将base64数据转换为data URL
                const imageUrl = `data:image/png;base64,${imageData}`;
                console.log('🖼️ 生成的图片Data URL长度:', imageUrl.length);
                return imageUrl;
                
            } catch (error) {
                console.error('❌ Gemini图片生成失败:', error);
                // 返回默认图片URL
                return './assets/mPreload.jpg';
            }
        }

        // 处理上传的图片
        async function processUploadedImage(file) {
            if (window.location.search.includes('debug=true')) {
                console.log('📁 处理用户上传的图片');
            }
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (window.location.search.includes('debug=true')) {
                        console.log('✅ 图片读取成功');
                    }
                    resolve(e.target.result);
                };
                reader.onerror = function() {
                    reject(new Error(i18n.t('errors.imageReadFailed')));
                };
                reader.readAsDataURL(file);
            });
        }

        // 渲染卡牌
        async function renderCard(cardAttributes, imageUrl) {
            showStatus(i18n.t('status.renderingCard'), 'info');
            
            // 🎯 关键修复：基于卡牌文本内容检测语言，而不是界面语言
            let cardText = cardAttributes.text || '';
            
            // 🔧 改进的语言检测：区分英文和所有其他语言（中日韩等）
            function detectCardLanguage(text) {
                if (!text) return 'english';
                
                // 检测中文字符（简体、繁体）
                if (/[\u4e00-\u9fff]/.test(text)) return 'chinese';
                
                // 检测日文字符（平假名、片假名、汉字）  
                if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'japanese';
                
                // 检测韩文字符
                if (/[\uac00-\ud7af]/.test(text)) return 'korean';
                
                // 默认为英文
                return 'english';
            }
            
            const cardLanguage = detectCardLanguage(cardText);
            const isEnglishCard = (cardLanguage === 'english');
            
            console.log('🔍 原始文本:', cardText);
            console.log('🔍 卡牌内容语言检测:', cardLanguage, isEnglishCard ? '(英文)' : '(非英文)');
            
            // 🔧 重要：基于卡牌内容语言重新配置Sunwell，确保语言路由一致性
            console.log('🛤️ 基于卡牌内容重新配置Sunwell路由');
            if (isEnglishCard) {
                // 🎯 英文内容：使用修复后的Sunwell配置
                console.log('🎨 英文内容：重新配置Sunwell为修复后配置');
                sunwell = new Sunwell({
                    assetFolder: './assets/',
                    // 🔧 应用修复方案中的字体配置
                    titleFont: "Belwe, Arial, sans-serif",
                    bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                    bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                    bodyFontSize: 38,
                    bodyLineHeight: 40,
                    bodyFontOffset: {x: 0, y: 30}, // 修复后的垂直位置
                    drawTimeout: 20000,
                    debug: false
                });
            } else {
                // 🎯 中文内容：配置Sunwell隐藏文本，使用外置文本框
                console.log('🎨 中文内容：重新配置Sunwell为外置文本框模式');
                sunwell = new Sunwell({
                    titleFont: "Arial, sans-serif",
                    bodyFontRegular: "Arial, sans-serif",
                    bodyFontItalic: "Arial, sans-serif",  
                    bodyFontBold: "Arial, sans-serif",
                    bodyFontBoldItalic: "Arial, sans-serif",
                    bodyFontSize: 1,  // 隐藏Sunwell文本
                    bodyLineHeight: 1,  
                    bodyFontOffset: {x: -9999, y: -9999},  // 移除屏幕外
                    gemFont: "Arial, sans-serif",
                    nameFont: "Arial, sans-serif",
                    assetFolder: './assets/',
                    drawTimeout: 20000,
                    debug: false
                });
            }
            
            // 🛤️ 统一关键词处理：所有语言都需要处理关键词加粗  
            if (cardText) {
                console.log(`🎨 ${cardLanguage}卡牌：处理关键词加粗`);
                console.log('🔍 处理前文本:', cardText);
                
                // 🔧 统一处理所有语言的关键词加粗（中英日韩）
                const processedResult = safeProcessKeywords(cardText);
                cardText = processedResult.processedText;
                
                console.log('🔍 处理后文本:', cardText);
                console.log('🔍 找到的关键词:', processedResult.foundKeywords);
                
                if (isEnglishCard) {
                    // 🎯 英文卡牌：交给Sunwell原装BodyText组件处理<b>标签
                    console.log('🎨 英文卡牌：交给Sunwell原装BodyText组件渲染');
                } else {
                    // 🎯 非英文卡牌：使用外置文本框自定义渲染方案
                    console.log(`🎨 ${cardLanguage}卡牌：使用外置文本框自定义渲染方案`);
                }
            }
            
            // 构建卡牌数据
            const cardData = {
                id: 'AI_' + Date.now(),
                name: cardAttributes.name,
                text: cardText, // 使用处理后的文本
                cost: cardAttributes.cost,
                attack: cardAttributes.attack,
                health: cardAttributes.health,
                cardClass: cardAttributes.cardClass,
                rarity: cardAttributes.rarity,
                type: 'MINION',
                race: cardAttributes.race || '',
                set: 'EXPERT1',
                collectible: true,
                texture: imageUrl,
                collectionText: cardText, // 使用处理后的文本
                flavor: '',
                elite: cardAttributes.rarity === 'LEGENDARY',
                silenced: false,
                hideStats: false,
                costsHealth: false,
                armor: 0
            };
            

            currentCardData = cardData;
            
            // 使用Sunwell渲染
            const canvas = document.getElementById('cardCanvas');
            if (!canvas) {
                throw new Error(i18n.t('errors.canvasNotFound'));
            }
            
            const isPremium = (cardData.rarity === 'LEGENDARY' || cardData.rarity === 'EPIC');
            
            console.log('🔍 传给Sunwell的卡牌数据:', cardData);
            console.log('🔍 特别是文本字段:', cardData.text);
            
            // 增强的超时和错误处理
            let isCompleted = false;
            const timeoutId = setTimeout(() => {
                if (!isCompleted) {
                    showStatus('卡牌生成超时，请检查文本内容或重试', 'error');
                    // 显示错误提示
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '20px Arial';
                    ctx.fillText('渲染超时 - 请检查文本后重试', 20, 100);
                }
            }, 20000);
            
            try {
                const card = sunwell.createCard(
                    cardData,
                    400,
                    isPremium,
                    canvas,
                    function(renderedCanvas) {
                        isCompleted = true;
                        clearTimeout(timeoutId);
                        
                        console.log('卡牌基础渲染完成');
                        
                        try {
                            // 🔧 关键修复：为英文模式保留原始文本，为中文模式使用处理后文本
                            const originalText = cardData.text;
                            
                            if (renderedCanvas && originalText && originalText.trim()) {
                                // 🎯 语言检测：在使用前先定义（与上面保持一致）
                                function detectTextLanguage(text) {
                                    if (!text) return 'english';
                                    
                                    // 检测中文字符（简体、繁体）
                                    if (/[\u4e00-\u9fff]/.test(text)) return 'chinese';
                                    
                                    // 检测日文字符（平假名、片假名、汉字）  
                                    if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'japanese';
                                    
                                    // 检测韩文字符
                                    if (/[\uac00-\ud7af]/.test(text)) return 'korean';
                                    
                                    // 默认为英文
                                    return 'english';
                                }
                                
                                const detectedLanguage = detectTextLanguage(originalText);
                                const isNonEnglish = (detectedLanguage !== 'english');
                                console.log(`🛤️ 语言路由检测: ${detectedLanguage} - "${originalText}"`);
                                
                                if (isNonEnglish) {
                                    // 🎯 非英文卡牌：使用外置文本框自定义渲染系统
                                    console.log(`🎨 ${detectedLanguage}卡牌：使用外置文本框自定义渲染系统`);
                                    
                                    // 🔧 修复：确保韩语等非英文文本进行关键词处理
                                    console.log(`🔍 ${detectedLanguage}文本关键词处理前: "${originalText}"`);
                                    const keywordResult = safeProcessKeywords(originalText);
                                    const processedText = keywordResult.processedText;
                                    console.log(`🔍 ${detectedLanguage}文本关键词处理后: "${processedText}"`);
                                    console.log(`🔍 找到的${detectedLanguage}关键词:`, keywordResult.foundKeywords);
                                    const textLength = processedText.length;
                                    
                                    // 智能字体选择（韩语优化）
                                    let fontSize = 20;
                                    
                                    // 检测是否为韩语文本并调整字体大小
                                    const isKoreanText = /[가-힯]/.test(originalText);
                                    
                                    if (isKoreanText) {
                                        // 韩语字体优化：平衡清晰度和边框限制
                                        if (textLength <= 15) fontSize = 22;  // 适中增加
                                        else if (textLength <= 30) fontSize = 21;  // 适中增加
                                        else if (textLength <= 50) fontSize = 20;  // 适中增加
                                        else fontSize = 19;  // 长文本保持紧凑
                                        console.log(`📏 韩语字体调整: ${fontSize}px (原始长度: ${textLength})`);
                                    } else {
                                        // 非韩语文本使用原有逻辑
                                        if (textLength <= 15) fontSize = 23;
                                        else if (textLength <= 30) fontSize = 21;
                                        else if (textLength <= 50) fontSize = 19;
                                    }
                                    
                                    // 🔧 使用实际测量的文本框宽度（炉石卡牌文本区域约215px）
                                    const lines = safeTextSplit(processedText, 215, fontSize);
                                    
                                    const textConfig = {
                                        text: originalText,
                                        processedText: processedText,
                                        fontSize: fontSize,
                                        lines: lines,
                                        isPremium: isPremium
                                    };
                                    
                                    safeRenderChineseText(renderedCanvas, textConfig);
                                    
                                    const colorInfo = isPremium ? '白色文字(金色)' : '黑色文字(普通)';
                                    showStatus(`中文卡牌生成成功！${fontSize}px字体，${lines.length}行，${colorInfo}`, 'success');
                                    
                                } else {
                                    // 🎯 英文卡牌：完全由Sunwell原生系统处理，不做任何自定义渲染
                                    console.log(`🎨 ${detectedLanguage}卡牌：完全跳过外置文本框，由Sunwell原生系统处理所有内容`);
                                    console.log(`🔍 ${detectedLanguage}文本交给Sunwell原生处理: "${originalText}"`);
                                    
                                    // 英文完全不进行任何自定义文本渲染，让Sunwell原生处理所有内容
                                    // 包括：字体大小、行高、换行、关键词加粗、文字位置等
                                    const colorInfo = isPremium ? '白色文字(金色)' : '黑色文字(普通)';
                                    showStatus(`英文卡牌生成成功！使用Sunwell原生方案，${colorInfo}`, 'success');
                                }
                                
                                // 🔧 修复：不再需要手动渲染中文名称，Sunwell已直接渲染
                                console.log(`✅ 卡牌名称由Sunwell直接渲染: "${cardData.name}"`);
                            } else {
                                showStatus(i18n.t('status.renderComplete'), 'success');
                            }
                        } catch (textError) {
                            console.error('❌ 中文文本渲染失败:', textError);
                            showStatus(`中文文本渲染失败: ${textError.message}`, 'error');
                        }
                    }
                );
            } catch (error) {
                clearTimeout(timeoutId);
                console.error('渲染卡牌失败:', error);

                throw new Error(i18n.t('errors.renderFailed') + ': ' + error.message);
            }
        }

        // 显示卡牌信息
        function displayCardInfo(cardData) {
            const cardInfo = document.getElementById('cardInfo');
            
            // 获取国际化翻译
            const getClassTranslation = (className) => {
                if (!className) return i18n.t('cardInfo.none');
                return i18n.t(`cardClasses.${className.toLowerCase()}`) || className;
            };
            
            const getRaceTranslation = (raceName) => {
                if (!raceName) return i18n.t('cardInfo.none');
                return i18n.t(`cardRaces.${raceName.toLowerCase()}`) || raceName;
            };
            
            const getRarityTranslation = (rarityName) => {
                if (!rarityName) return i18n.t('cardInfo.none');
                return i18n.t(`cardRarities.${rarityName.toLowerCase()}`) || rarityName;
            };
            
            cardInfo.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; color: #333;">📋 ${i18n.t('cardInfo.title')}</h4>
                    <div><strong>${i18n.t('cardInfo.name')}:</strong> ${cardData.name}</div>
                    <div><strong>${i18n.t('cardInfo.cost')}:</strong> ${cardData.cost}</div>
                    <div><strong>${i18n.t('cardInfo.attack')}:</strong> ${cardData.attack}</div>
                    <div><strong>${i18n.t('cardInfo.health')}:</strong> ${cardData.health}</div>
                    <div><strong>${i18n.t('cardInfo.class')}:</strong> ${getClassTranslation(cardData.cardClass || cardData.playerClass)}</div>
                    <div><strong>${i18n.t('cardInfo.race')}:</strong> ${getRaceTranslation(cardData.race)}</div>
                    <div><strong>${i18n.t('cardInfo.rarity')}:</strong> ${getRarityTranslation(cardData.rarity)}</div>
                    <div style="margin-top: 10px;"><strong>${i18n.t('cardInfo.description')}:</strong> ${cardData.text || cardData.description}</div>
                </div>
            `;
        }

        // 错误处理
        window.addEventListener('error', function(e) {
            console.error('❌ 页面错误:', e.error);
            showStatus(i18n.t('errors.pageError'), 'error');
        });

        // 调试信息 - 静默模式
        if (window.location.search.includes('debug=true')) {
            console.log('🎮 AI炉石传说卡牌生成器已加载');
            console.log('🔑 Gemini API Key已配置');
        }
    </script>
</body>
</html>