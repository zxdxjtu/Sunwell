<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç‚‰çŸ³ä¼ è¯´å¡ç‰Œç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 30px;
        }

        .language-selector select {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .language-selector select:hover {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            padding: 30px;
        }

        .input-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 1rem;
        }

        .form-group textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-upload-label {
            display: block;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .file-upload-label:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-upload-label.dragover {
            border-color: #667eea;
            background: #e8f2ff;
        }

        .generate-btn {
            width: 100%;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .card-preview {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .card-preview h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3rem;
        }

        #cardCanvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 500;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .example-prompts {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .example-prompts h4 {
            margin-bottom: 10px;
            color: #333;
            font-size: 1rem;
        }

        .example-prompt {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            background: #e9ecef;
            border: none;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-prompt:hover {
            background: #667eea;
            color: white;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* ğŸ¯ é—®é¢˜å·²é€šè¿‡æºç ä¿®æ”¹æ°¸ä¹…è§£å†³ï¼Œç§»é™¤ä¸´æ—¶CSSä¿®å¤ */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="language-selector">
                <select id="languageSelect" class="language-selector" onchange="changeLanguage(this.value)">
                    <option value="zh-CN">ç®€ä½“ä¸­æ–‡</option>
                    <option value="zh-TW">ç¹é«”ä¸­æ–‡</option>
                    <option value="en-US">English</option>
                    <option value="ja-JP">æ—¥æœ¬èª</option>
                    <option value="ko-KR">í•œêµ­ì–´</option>
                </select>
            </div>
            <h1 data-i18n="title">ğŸ® AIç‚‰çŸ³ä¼ è¯´å¡ç‰Œç”Ÿæˆå™¨</h1>
            <p data-i18n="subtitle">é€šè¿‡AIæ™ºèƒ½ç”Ÿæˆç‹¬ç‰¹çš„ç‚‰çŸ³ä¼ è¯´å¡ç‰Œï¼Œæ”¯æŒæ–‡å­—æè¿°å’Œå›¾ç‰‡ç”Ÿæˆ</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <div class="form-group">
                    <label for="cardPrompt" data-i18n="cardPromptLabel">ğŸ“ å¡ç‰Œæè¿°æç¤ºè¯</label>
                    <textarea 
                        id="cardPrompt" 
                        data-i18n-placeholder="cardPromptPlaceholder"
                    ></textarea>
                </div>

                <div class="example-prompts">
                    <h4 data-i18n="examplePromptsTitle">ğŸ’¡ ç¤ºä¾‹æç¤ºè¯ï¼š</h4>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.shadowAssassin'))" data-i18n="examples.shadowAssassinButton">æš—å½±åˆºå®¢</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.ancientDragon'))" data-i18n="examples.ancientDragonButton">å¤è€å·¨é¾™</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.healingPaladin'))" data-i18n="examples.healingPaladinButton">æ²»ç–—åœ£éª‘å£«</button>
                    <button class="example-prompt" onclick="setPrompt(i18n.t('examples.demonSummon'))" data-i18n="examples.demonSummonButton">æ¶é­”å¬å”¤ç‰©</button>
                </div>

                <div class="form-group">
                    <label for="cardImage" data-i18n="cardImageLabel">ğŸ–¼ï¸ å¡ç‰Œå›¾ç‰‡ï¼ˆå¯é€‰ï¼‰</label>
                    <div class="file-upload">
                        <input type="file" id="cardImage" accept="image/*">
                        <label for="cardImage" class="file-upload-label">
                            <div data-i18n="fileUploadText">ğŸ“ ç‚¹å‡»é€‰æ‹©å›¾ç‰‡æˆ–æ‹–æ‹½åˆ°æ­¤å¤„</div>
                            <div style="font-size: 0.9rem; color: #666; margin-top: 5px;" data-i18n="fileUploadHint">å¦‚æœä¸ä¸Šä¼ å›¾ç‰‡ï¼ŒAIå°†è‡ªåŠ¨ç”Ÿæˆç‚‰çŸ³ä¼ è¯´é£æ ¼çš„å›¾ç‰‡</div>
                        </label>
                    </div>
                </div>

                <button id="generateBtn" class="generate-btn" onclick="generateAICard()" data-i18n="generateButton">
                    âœ¨ ç”ŸæˆAIå¡ç‰Œ
                </button>

                <div id="loading" class="loading">
                    <div class="spinner"></div>
                    <div id="loadingText" data-i18n="loadingText">æ­£åœ¨ç”Ÿæˆå¡ç‰Œ...</div>
                </div>

                <div id="statusMessage" class="status-message" style="display: none;"></div>
            </div>

            <div class="card-preview">
                <h3 data-i18n="cardPreviewTitle">ğŸ´ å¡ç‰Œé¢„è§ˆ</h3>
                <canvas id="cardCanvas" width="400" height="560"></canvas>
                <div id="cardInfo" style="margin-top: 15px; text-align: left; font-size: 0.9rem; color: #666;"></div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½å¿…è¦çš„è„šæœ¬ -->
    <script src="./prompts.js"></script>
<script src="./card-prompts.js"></script>

    <!-- ğŸš¨ å…³é”®ä¿®å¤ï¼šåœ¨SunwellåŠ è½½å‰å®šä¹‰charså’ŒLineBreakerå‡½æ•° -->
    <script>
        // ğŸ”§ ä¿®å¤ï¼šå®Œæ•´å®šä¹‰Sunwelléœ€è¦çš„charså‡½æ•°
        function chars(text) {
            if (!text || typeof text !== 'string') return [];
            return Array.from(text);
        }
        
        // chars.categoryå‡½æ•° - Unicodeå­—ç¬¦åˆ†ç±»
        chars.category = function(char) {
            if (!char || typeof char !== 'string') return 'P';
            
            const code = char.codePointAt(0);
            
            // CJKç»Ÿä¸€æ±‰å­—
            if (code >= 0x4E00 && code <= 0x9FFF) return 'Lo';
            // CJKæ‰©å±•A
            if (code >= 0x3400 && code <= 0x4DBF) return 'Lo';
            // CJKå…¼å®¹æ±‰å­—
            if (code >= 0xF900 && code <= 0xFAFF) return 'Lo';
            // è‹±æ–‡å­—æ¯
            if ((code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A)) return 'L';
            // æ•°å­—
            if (code >= 0x30 && code <= 0x39) return 'N';
            // ç©ºç™½å­—ç¬¦
            if (/\s/.test(char)) return 'Z';
            // æ ‡ç‚¹ç¬¦å·
            if (/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š""''ï¼ˆï¼‰ã€ã€‘ã€Šã€‹]/.test(char)) return 'P';
            
            return 'P';
        };

        // LineBreakerå‡½æ•°
        window.LineBreaker = function(text) {
            this.text = text || '';
            this.pos = 0;
        };

        window.LineBreaker.prototype.nextBreak = function() {
            if (this.pos >= this.text.length) {
                return null;
            }
            
            const nextPos = this.pos + 1;
            const result = {
                position: nextPos,
                required: false
            };
            
            this.pos = nextPos;
            return result;
        };
        
        // ç¡®ä¿å…¨å±€å¯è®¿é—®
        window.chars = chars;
        if (typeof global === 'undefined') {
            var global = window;
        }
        global.chars = chars;
        
        console.log('ğŸš¨ åœ¨SunwellåŠ è½½å‰è®¾ç½®charså‡½æ•°:', {
            'window.chars': typeof window.chars,
            'global.chars': typeof global.chars,
            'chars': typeof chars,
            'æµ‹è¯•chars("test")': window.chars ? window.chars("test") : 'undefined'
        });
    </script>

<script src="./dist/sunwell.browser.js"></script>
<script src="./i18n/i18n.js?v=1.0.1"></script>
    <!-- ä½¿ç”¨æœ¬åœ°å®ç°æ›¿ä»£Google Generative AI -->
    
    <script>
        // å…¨å±€å˜é‡
        let sunwell = null;
        let currentCardData = null;
        
        // Gemini APIé…ç½® - ä»ç¯å¢ƒå˜é‡æˆ–é…ç½®ä¸­è·å–
        const GEMINI_API_KEY = getApiKey();
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        
        // è·å–APIå¯†é’¥çš„å‡½æ•°
        function getApiKey() {
            // å°è¯•ä»å¤šä¸ªæ¥æºè·å–APIå¯†é’¥
            if (typeof process !== 'undefined' && process.env && process.env.GEMINI_API_KEY) {
                return process.env.GEMINI_API_KEY;
            }
            
            // ä»localStorageè·å–ï¼ˆç”¨æˆ·æ‰‹åŠ¨è®¾ç½®ï¼‰
            const storedKey = localStorage.getItem('GEMINI_API_KEY');
            if (storedKey) {
                return storedKey;
            }
            
            // ä»URLå‚æ•°è·å–ï¼ˆå¼€å‘æµ‹è¯•ç”¨ï¼‰
            const urlParams = new URLSearchParams(window.location.search);
            const urlKey = urlParams.get('api_key');
            if (urlKey) {
                return urlKey;
            }
            
            // æç¤ºç”¨æˆ·è®¾ç½®APIå¯†é’¥
            const userKey = prompt('è¯·è¾“å…¥æ‚¨çš„Gemini APIå¯†é’¥ (å°†ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨):');
            if (userKey) {
                localStorage.setItem('GEMINI_API_KEY', userKey);
                return userKey;
            }
            
            throw new Error('æœªæ‰¾åˆ°Gemini APIå¯†é’¥ï¼Œè¯·è®¾ç½®ç¯å¢ƒå˜é‡GEMINI_API_KEYæˆ–æ‰‹åŠ¨è¾“å…¥');
        }
        
        // è°ƒè¯•æ—¥å¿—å‡½æ•°
        function debugLog(message, data = null) {
            console.log(`ğŸ” ${message}`, data || '');
        }
        
        // å…¨å±€å˜é‡
        let uploadedImage = null;


        // ğŸ”§ ç‚‰çŸ³ä¼ è¯´å…³é”®è¯åˆ—è¡¨ï¼ˆä¸­è‹±æ–‡ï¼‰
        const hearthstoneKeywords = [
            // ç®€ä½“ä¸­æ–‡å…³é”®è¯
            'æˆ˜å¼', 'äº¡è¯­', 'å˜²è®½', 'å†²é”‹', 'æ½œè¡Œ', 'åœ£ç›¾', 'å‰§æ¯’', 'é£æ€’', 
            'ç”Ÿå‘½å·å–', 'æ³•æœ¯ä¼¤å®³', 'è¿‡è½½', 'è¿å‡»', 'å¥¥ç§˜', 'ä»»åŠ¡', 'å‘ç°',
            'æ¿€åŠ±', 'é€‚åº”æ€§', 'æ‹›å‹Ÿ', 'å›å“', 'ç£åŠ›', 'å¥‡æ•°', 'å¶æ•°',
            // ç¹ä½“ä¸­æ–‡å…³é”®è¯
            'æˆ°å¼', 'äº¡èª', 'å˜²è«·', 'è¡é‹’', 'æ½›è¡Œ', 'è–ç›¾', 'åŠ‡æ¯’', 'é¢¨æ€’',
            'ç”Ÿå‘½å·å–', 'æ³•è¡“å‚·å®³', 'éè¼‰', 'é€£æ“Š', 'å¥§ç§˜', 'ä»»å‹™', 'ç™¼ç¾',
            'æ¿€å‹µ', 'é©æ‡‰æ€§', 'æ‹›å‹Ÿ', 'å›éŸ¿', 'ç£åŠ›', 'å¥‡æ•¸', 'å¶æ•¸',
            // æ—¥è¯­å…³é”®è¯ï¼ˆåŒ…å«å˜ä½“ï¼‰
            'é›„ãŸã‘ã³', 'é›„å«ã³', 'æ–­æœ«é­”', 'æŒ‘ç™º', 'çªæ’ƒ', 'çªé€²', 'éš å¯†', 'è–ãªã‚‹ç›¾', 'çŒ›æ¯’', 'ç–¾é¢¨',
            'ç”Ÿå‘½å¥ªå–', 'å‘ªæ–‡ãƒ€ãƒ¡ãƒ¼ã‚¸', 'ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰', 'ã‚³ãƒ³ãƒœ', 'ç§˜ç­–', 'ã‚¯ã‚¨ã‚¹ãƒˆ', 'ç™ºè¦‹',
            'é¼“èˆ', 'é©å¿œ', 'å‹§èª˜', 'ã‚¨ã‚³ãƒ¼', 'ãƒã‚°ãƒãƒƒãƒˆ', 'ã‚ªãƒ¼ãƒãƒ¼ã‚­ãƒ«',
            // éŸ©è¯­å…³é”®è¯
            'ì „íˆ¬ì˜ í•¨ì„±', 'ì£½ìŒì˜ ë©”ì•„ë¦¬', 'ë„ë°œ', 'ëŒì§„', 'ì€ì‹ ', 'ì„±ìŠ¤ëŸ¬ìš´ ë³´í˜¸ë§‰', 'ë§¹ë…', 'ì§ˆí’',
            'ìƒëª…ë ¥ í¡ìˆ˜', 'ì£¼ë¬¸ë ¥', 'ê³¼ë¶€í•˜', 'ì—°ê³„', 'ë¹„ë°€', 'í€˜ìŠ¤íŠ¸', 'ë°œê²¬',
            'ê²©ë ¤', 'ì ì‘', 'ëª¨ì§‘', 'ë©”ì•„ë¦¬', 'ìê¸°ë ¥', 'ëŒê²©', 'ê³¼ë„í•œ ì‚´ìƒ',
            // è‹±æ–‡å…³é”®è¯
            'Battlecry', 'Deathrattle', 'Taunt', 'Charge', 'Stealth', 'Divine Shield', 
            'Poisonous', 'Windfury', 'Lifesteal', 'Spell Damage', 'Overload', 'Combo',
            'Secret', 'Quest', 'Discover', 'Inspire', 'Adapt', 'Recruit', 'Echo',
            'Magnetic', 'Rush', 'Overkill', 'Twinspell', 'Reborn'
        ];

        // ğŸ›¡ï¸ å®‰å…¨çš„å…³é”®è¯å¤„ç†å‡½æ•°
        function safeProcessKeywords(text) {
            if (!text || typeof text !== 'string') {
                return { processedText: '', foundKeywords: [] };
            }
            
            let result = text;
            let foundKeywords = [];
            
            try {
                // ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢ï¼Œé¿å…å¤æ‚æ­£åˆ™è¡¨è¾¾å¼
                hearthstoneKeywords.forEach(keyword => {
                    if (!keyword) return;
                    
                    // ğŸ”§ æ”¯æŒä¸­è‹±æ–‡æ ‡ç‚¹ç¬¦å·
                    const patterns = [
                        { search: keyword + 'ï¼š', replace: `<b>${keyword}</b>ï¼š` }, // ä¸­æ–‡å†’å·
                        { search: keyword + ':', replace: `<b>${keyword}</b>:` },   // è‹±æ–‡å†’å·
                        { search: keyword + ' ', replace: `<b>${keyword}</b> ` }    // ç©ºæ ¼åˆ†éš”
                    ];
                    
                    patterns.forEach(pattern => {
                        let lastResult = result;
                        result = result.split(pattern.search).join(pattern.replace);
                        
                        // å¦‚æœæœ‰æ›¿æ¢ï¼Œè®°å½•å…³é”®è¯
                        if (result !== lastResult && !foundKeywords.includes(keyword)) {
                            foundKeywords.push(keyword);
                        }
                    });
                });

                console.log('ğŸ”§ å…³é”®è¯å¤„ç†å®Œæˆ:', { foundKeywords, processedText: result });
                return { processedText: result, foundKeywords };
                
            } catch (error) {
                console.error('âŒ å…³é”®è¯å¤„ç†å‡ºé”™:', error);
                return { processedText: text, foundKeywords: [] };
            }
        }

        // ğŸ›¡ï¸ å®‰å…¨çš„æ–‡æœ¬åˆ†å‰²å‡½æ•°ï¼ˆæ”¯æŒå¤šè¯­è¨€ï¼‰
        function safeTextSplit(text, maxWidth, fontSize) {
            if (!text || typeof text !== 'string') {
                return [''];
            }
            
            // ğŸ”§ æ”¹è¿›çš„è¯­è¨€æ£€æµ‹ï¼ˆä¸ä¸Šé¢ä¿æŒä¸€è‡´ï¼‰
            function detectSplitLanguage(text) {
                if (!text) return 'english';
                
                // æ£€æµ‹ä¸­æ–‡å­—ç¬¦ï¼ˆç®€ä½“ã€ç¹ä½“ï¼‰
                if (/[\u4e00-\u9fff]/.test(text)) return 'cjk';
                
                // æ£€æµ‹æ—¥æ–‡å­—ç¬¦ï¼ˆå¹³å‡åã€ç‰‡å‡åã€æ±‰å­—ï¼‰  
                if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'cjk';
                
                // æ£€æµ‹éŸ©æ–‡å­—ç¬¦
                if (/[\uac00-\ud7af]/.test(text)) return 'cjk';
                
                // é»˜è®¤ä¸ºè‹±æ–‡
                return 'english';
            }
            
            const textLanguage = detectSplitLanguage(text);
            
            if (textLanguage === 'cjk') {
                // CJKæ–‡æœ¬ï¼ˆä¸­æ—¥éŸ©ï¼‰ï¼šåŸºäºå­—ç¬¦æ•°åˆ†è¡Œ
                const targetCharsPerLine = 11;
                return safeChineseSplit(text, targetCharsPerLine, maxWidth, fontSize);
            } else {
                // è‹±æ–‡æ–‡æœ¬ï¼šåŸºäºå•è¯åˆ†è¡Œ
                return safeEnglishSplit(text, maxWidth, fontSize);
            }
        }
        
        // ğŸ”§ æ–°å¢ï¼šè‹±æ–‡æ–‡æœ¬åˆ†è¡Œå‡½æ•°
        function safeEnglishSplit(text, maxWidth, fontSize) {
            console.log(`ğŸ“ è‹±æ–‡åˆ†è¡Œ: maxWidth=${maxWidth}, fontSize=${fontSize}`);
            console.log(`ğŸ“ è‹±æ–‡åŸå§‹æ–‡æœ¬: "${text}"`);
            
            const lines = [];
            const words = text.split(/\s+/); // æŒ‰ç©ºæ ¼åˆ†è¯
            let currentLine = '';
            
            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine ? currentLine + ' ' + word : word;
                
                // ä¼°ç®—è¡Œé•¿åº¦ï¼ˆè‹±æ–‡çº¦35å­—ç¬¦/è¡Œé€‚åˆç‚‰çŸ³å¡ç‰Œï¼‰
                if (testLine.replace(/<\/?b>/g, '').length > 35 && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            console.log(`ğŸ“ è‹±æ–‡åˆ†è¡Œå®Œæˆï¼Œå…±${lines.length}è¡Œ:`, lines);
            return lines.length > 0 ? lines : [''];
        }
        
        // ğŸ”§ ä¸­æ–‡åˆ†è¡Œå‡½æ•°ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
        function safeChineseSplit(text, targetCharsPerLine, maxWidth, fontSize) {
            
            // è°ƒè¯•ä¿¡æ¯
            console.log(`ğŸ“ CJKåˆ†è¡Œå‚æ•°: maxWidth=${maxWidth}, fontSize=${fontSize}, targetCharsPerLine=${targetCharsPerLine}`);
            console.log(`ğŸ“ åŸå§‹æ–‡æœ¬: "${text}"`);
            console.log(`ğŸ“ æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«<b>æ ‡ç­¾:`, text.includes('<b>'));
            
            // ğŸ”§ éŸ©è¯­æ–‡æœ¬å¤„ç†ï¼šä¸“é—¨ä¼˜åŒ–éŸ©è¯­å­—ç¬¦å¯†åº¦
            const cleanTextLength = text.replace(/<\/?b>/g, '').length;
            let adjustedCharsPerLine = targetCharsPerLine;
            let maxLines = 4;
            
            // æ£€æµ‹æ˜¯å¦ä¸ºéŸ©è¯­æ–‡æœ¬
            const isKoreanText = /[ê°€-í¯]/.test(text);
            
            if (isKoreanText) {
                // ğŸ”§ éŸ©è¯­ä¸“ç”¨å‚æ•°ï¼šå……åˆ†åˆ©ç”¨è¡Œç©ºé—´ï¼Œå¢åŠ 2-3å­—ç¬¦å®¹é‡
                if (cleanTextLength > 60) {
                    adjustedCharsPerLine = 14;  // éŸ©è¯­è¶…é•¿æ–‡æœ¬ï¼šå¢åŠ å®¹é‡
                    maxLines = 5;
                } else if (cleanTextLength > 40) {
                    adjustedCharsPerLine = 15;  // éŸ©è¯­ä¸­é•¿æ–‡æœ¬ï¼šå¢åŠ å®¹é‡
                    maxLines = 4;
                } else {
                    adjustedCharsPerLine = 16;  // éŸ©è¯­çŸ­æ–‡æœ¬ï¼šå¢åŠ å®¹é‡
                    maxLines = 3;
                }
                console.log(`ğŸ“ éŸ©è¯­æ–‡æœ¬æ£€æµ‹(${cleanTextLength}å­—ç¬¦)ï¼Œè°ƒæ•´å‚æ•°: æ¯è¡Œ${adjustedCharsPerLine}å­—ï¼Œæœ€å¤š${maxLines}è¡Œ`);
            } else {
                // ééŸ©è¯­æ–‡æœ¬çš„åŸæœ‰é€»è¾‘
                if (cleanTextLength > 60) {
                    adjustedCharsPerLine = 8;
                    maxLines = 6;
                } else if (cleanTextLength > 40) {
                    adjustedCharsPerLine = 9;
                    maxLines = 5;
                }
                console.log(`ğŸ“ CJKééŸ©è¯­æ–‡æœ¬(${cleanTextLength}å­—ç¬¦)ï¼Œè°ƒæ•´å‚æ•°: æ¯è¡Œ${adjustedCharsPerLine}å­—ï¼Œæœ€å¤š${maxLines}è¡Œ`);
            }
            
            let lines = [];
            let currentLine = '';
            let i = 0;
            
            // å®‰å…¨è®¡æ•°å™¨
            const safeLimit = text.length + 50;
            let iterations = 0;
            
            while (i < text.length && lines.length < maxLines && iterations < safeLimit) {
                iterations++;
                
                // ğŸ”§ ä¿®å¤ï¼šå¤„ç†ç²—ä½“æ ‡è®°åŠåç»­å­—ç¬¦
                if (text.substr(i, 3) === '<b>') {
                    console.log(`ğŸ“ åœ¨åˆ†å‰²ä¸­æ‰¾åˆ°<b>æ ‡ç­¾åœ¨ä½ç½® ${i}`);
                    const endIndex = text.indexOf('</b>', i);
                    if (endIndex > i) {
                        const boldBlock = text.substring(i, endIndex + 4);
                        const boldText = text.substring(i + 3, endIndex);
                        console.log(`ğŸ“ åˆ†å‰²ä¸­çš„ç²—ä½“å—: "${boldBlock}", ç²—ä½“æ–‡æœ¬: "${boldText}"`);
                        
                        // ğŸ”§ å…³é”®ä¿®å¤ï¼šæˆ˜å¼ç­‰å…³é”®è¯åçš„å†’å·ä¸åº”å¯¼è‡´æ¢è¡Œ
                        let estimatedLength = boldText.length;
                        const nextCharIndex = endIndex + 4;
                        let nextChar = '';
                        if (nextCharIndex < text.length) {
                            nextChar = text[nextCharIndex];
                            if (/[ï¼šï¼Œã€‚ï¼ï¼Ÿï¼›]/.test(nextChar)) {
                                estimatedLength += 1; // æ ‡ç‚¹ç¬¦å·è®¡å…¥é•¿åº¦
                            }
                        }
                        
                        // ç‰¹æ®Šå¤„ç†ï¼šå…³é”®è¯+å†’å·çš„ç»„åˆä¼˜å…ˆä¿æŒåœ¨åŒä¸€è¡Œï¼ˆæ”¯æŒå¤šè¯­è¨€ï¼‰
                        const isKeywordColon = /^(æˆ˜å¼|äº¡è¯­|å˜²è®½|å†²é”‹|æ½œè¡Œ|åœ£ç›¾|å‰§æ¯’|é£æ€’|ç”Ÿå‘½å·å–|æ³•æœ¯ä¼¤å®³|è¿‡è½½|è¿å‡»|å¥¥ç§˜|ä»»åŠ¡|å‘ç°|ì „íˆ¬ì˜ í•¨ì„±|ì£½ìŒì˜ ë©”ì•„ë¦¬|ë„ë°œ|ëŒì§„|ì€ì‹ |ì„±ìŠ¤ëŸ¬ìš´ ë³´í˜¸ë§‰|ë§¹ë…|ì§ˆí’|ìƒëª…ë ¥ í¡ìˆ˜|ì£¼ë¬¸ë ¥|ê³¼ë¶€í•˜|ì—°ê³„|ë¹„ë°€|í€˜ìŠ¤íŠ¸|ë°œê²¬|Battlecry|Deathrattle|Taunt|Charge|Stealth|Divine Shield|Poisonous|Windfury|Lifesteal|Spell Damage|Overload|Combo)$/.test(boldText) && /[ï¼š:]/.test(nextChar);
                        
                        // ğŸ”§ ä½¿ç”¨ç²¾ç¡®çš„é•¿åº¦æ£€æŸ¥ï¼šç§»é™¤æ ‡ç­¾è®¡ç®—å®é™…å­—ç¬¦æ•°
                        const currentEffectiveLength = currentLine.replace(/<\/?b>/g, '').length;
                        
                        if (currentEffectiveLength + estimatedLength > adjustedCharsPerLine && currentLine && !isKeywordColon) {
                            lines.push(currentLine);
                            currentLine = boldBlock;
                        } else {
                            currentLine += boldBlock;
                        }
                        i = endIndex + 4;
                        continue;
                    }
                }
                
                // æ™®é€šå­—ç¬¦å¤„ç†
                const char = text[i];
                
                // ğŸ”§ ç‰¹æ®Šå¤„ç†ï¼šå†’å·ä¼˜å…ˆä¸å‰é¢å†…å®¹ä¿æŒåœ¨åŒä¸€è¡Œ
                const isColonAfterKeyword = char === 'ï¼š' && currentLine.includes('</b>');
                
                // ğŸ”§ éŸ©è¯­æ™ºèƒ½æ¢è¡Œï¼šè€ƒè™‘æ ‡ç‚¹ç¬¦å·å’Œè¯­ä¹‰åˆ†å‰²
                const effectiveLength = currentLine.replace(/<\/?b>/g, '').length;
                
                // éŸ©è¯­æ™ºèƒ½æ¢è¡Œï¼šåœ¨å¥å·ã€é€—å·åä¼˜å…ˆæ¢è¡Œï¼Œé¿å…è¡Œé¦–å‡ºç°æ ‡ç‚¹
                const nextChar = i + 1 < text.length ? text[i + 1] : '';
                const isKoreanPunctuation = /[.,;!?]/.test(char);
                const shouldBreakAfterPunctuation = isKoreanText && isKoreanPunctuation && effectiveLength >= adjustedCharsPerLine * 0.7;
                const isGoodBreakPoint = shouldBreakAfterPunctuation && /\s/.test(nextChar);
                
                // éŸ©è¯­ç‰¹æ®Šå¤„ç†ï¼šé¿å…è¿‡çŸ­çš„å•è¯ç‹¬å ä¸€è¡Œ
                const isShortWord = isKoreanText && effectiveLength < adjustedCharsPerLine * 0.5;
                const shouldAvoidEarlyBreak = isShortWord && !/[.,!?]/.test(char);
                
                if ((effectiveLength >= adjustedCharsPerLine && currentLine && !isColonAfterKeyword && !shouldAvoidEarlyBreak) || isGoodBreakPoint) {
                    // éŸ©è¯­ç‰¹æ®Šå¤„ç†ï¼šæ ‡ç‚¹ç¬¦å·å’Œå…¶åçš„ç©ºæ ¼ä¸€èµ·ä¿ç•™åœ¨å½“å‰è¡Œ
                    if (isGoodBreakPoint) {
                        currentLine += char;
                        if (/\s/.test(nextChar)) {
                            i++; // è·³è¿‡åé¢çš„ç©ºæ ¼
                            currentLine += ' ';
                        }
                    }
                    lines.push(currentLine);
                    currentLine = isGoodBreakPoint ? '' : char;
                } else {
                    currentLine += char;
                }
                i++;
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // ğŸ”§ éŸ©è¯­æ ‡ç‚¹ç¬¦å·å¤„ç†ï¼šé¿å…æ ‡ç‚¹ç¬¦å·å•ç‹¬æˆè¡Œ
            if (isKoreanText && lines.length > 0) {
                const processedLines = [];
                for (let j = 0; j < lines.length; j++) {
                    const line = lines[j].trim();
                    const cleanLine = line.replace(/<\/?b>/g, '');
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å•ç‹¬çš„æ ‡ç‚¹ç¬¦å·è¡Œ
                    const isPunctuationOnlyLine = /^[.,!?;:]+$/.test(cleanLine);
                    
                    if (isPunctuationOnlyLine && processedLines.length > 0) {
                        // å°†æ ‡ç‚¹ç¬¦å·åˆå¹¶åˆ°å‰ä¸€è¡Œ
                        processedLines[processedLines.length - 1] += line;
                        console.log(`ğŸ“ éŸ©è¯­æ ‡ç‚¹åˆå¹¶: å°†"${line}"åˆå¹¶åˆ°å‰ä¸€è¡Œ`);
                    } else if (cleanLine.length <= 3 && processedLines.length > 0) {
                        // è¶…çŸ­è¡Œï¼ˆ3å­—ç¬¦ä»¥ä¸‹ï¼‰ä¹Ÿå°è¯•åˆå¹¶åˆ°å‰ä¸€è¡Œ
                        const prevLine = processedLines[processedLines.length - 1];
                        const prevCleanLine = prevLine.replace(/<\/?b>/g, '');
                        if (prevCleanLine.length + cleanLine.length <= adjustedCharsPerLine) {
                            processedLines[processedLines.length - 1] += ' ' + line;
                            console.log(`ğŸ“ éŸ©è¯­çŸ­è¡Œåˆå¹¶: å°†"${line}"åˆå¹¶åˆ°å‰ä¸€è¡Œ`);
                        } else {
                            processedLines.push(line);
                        }
                    } else {
                        processedLines.push(line);
                    }
                }
                lines = processedLines;
                console.log(`ğŸ“ éŸ©è¯­æ ‡ç‚¹å¤„ç†åè¡Œæ•°: ${lines.length}`);
            }
            
            // ğŸ”§ éŸ©è¯­é•¿æ–‡æœ¬å¤„ç†ï¼šå¦‚æœè¡Œæ•°ä»ç„¶è¿‡å¤šï¼Œåˆå¹¶çŸ­è¡Œé¿å…Canvasé”™è¯¯
            if (lines.length > 4) {
                console.log(`ğŸ“ âš ï¸ è¡Œæ•°è¿‡å¤š(${lines.length})ï¼Œå°è¯•åˆå¹¶çŸ­è¡Œé¿å…Canvasé”™è¯¯`);
                const mergedLines = [];
                let tempLine = '';
                
                for (let j = 0; j < lines.length; j++) {
                    const line = lines[j];
                    const cleanLine = line.replace(/<\/?b>/g, '');
                    
                    if (tempLine && (tempLine.replace(/<\/?b>/g, '').length + cleanLine.length <= adjustedCharsPerLine + 2)) {
                        tempLine += line;
                    } else {
                        if (tempLine) mergedLines.push(tempLine);
                        tempLine = line;
                    }
                }
                if (tempLine) mergedLines.push(tempLine);
                
                // åªå–å‰4è¡Œé¿å…Canvasé”™è¯¯
                const finalLines = mergedLines.slice(0, 4);
                console.log(`ğŸ“ åˆå¹¶åè¡Œæ•°: ${finalLines.length}`);
                
                finalLines.forEach((line, index) => {
                    console.log(`ğŸ“ åˆå¹¶åç¬¬${index}è¡Œ: "${line}"`);
                });
                
                return finalLines;
            }
            
            console.log(`ğŸ“ CJKæ–‡æœ¬åˆ†å‰²å®Œæˆï¼Œå…±${lines.length}è¡Œ:`);
            lines.forEach((line, index) => {
                console.log(`ğŸ“ ç¬¬${index}è¡Œ: "${line}"`);
                console.log(`ğŸ“ ç¬¬${index}è¡ŒåŒ…å«<b>æ ‡ç­¾:`, line.includes('<b>'));
            });
            
            return lines.length > 0 ? lines : [''];
        }

        // ğŸ›¡ï¸ å®‰å…¨çš„ä¸­æ–‡æ–‡æœ¬æ¸²æŸ“
        function safeRenderChineseText(canvas, textConfig) {
            if (!canvas || !textConfig) return;
            
            const ctx = canvas.getContext('2d');
            const { text, fontSize = 20, lines, keywords = [], isPremium = false } = textConfig;
            
            try {
                // ğŸ”§ æ–°åŠŸèƒ½ï¼šæ ¹æ®å¡ç‰Œç±»å‹åŠ¨æ€è°ƒæ•´æ–‡å­—é¢œè‰²å’Œæè¾¹
                // é‡‘è‰²ä¼ è¯´/å²è¯—ï¼šç™½è‰²æ–‡å­— + æ·±è‰²æè¾¹ï¼Œæ™®é€šå¡ç‰Œï¼šé»‘è‰²æ–‡å­—æ— æè¾¹
                const textColor = isPremium ? '#FFFFFF' : '#000000';
                const useStroke = isPremium; // é‡‘è‰²å¡ç‰Œä½¿ç”¨æè¾¹å¢å¼ºå¯è¯»æ€§
                
                ctx.fillStyle = textColor;
                if (useStroke) {
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; // åŠé€æ˜é»‘è‰²æè¾¹
                    ctx.lineWidth = 1.5; // è½»å¾®æè¾¹
                }
                ctx.textAlign = 'left';
                ctx.textBaseline = 'ideographic';
                
                console.log(`ğŸ¨ æ–‡å­—è®¾ç½®: isPremium=${isPremium}, textColor=${textColor}, stroke=${useStroke}`);
                
                
                const baseX = 88;
                const baseY = 385;
                const lineHeight = Math.round(fontSize * 1.3);
                
                console.log('ğŸ” safeRenderChineseText å¼€å§‹æ¸²æŸ“ï¼Œæ€»è¡Œæ•°:', lines.length);
                console.log('ğŸ” æ‰€æœ‰è¡Œå†…å®¹:', lines);
                
                lines.forEach((line, lineIndex) => {
                    if (lineIndex >= 6) return; // æœ€å¤š6è¡Œä¿æŠ¤
                    
                    console.log(`ğŸ” å¤„ç†ç¬¬${lineIndex}è¡Œ: "${line}"`);
                    console.log(`ğŸ” è¡Œä¸­æ˜¯å¦åŒ…å«<b>æ ‡ç­¾:`, line.includes('<b>'));
                    
                    let currentX = baseX;
                    const y = baseY + fontSize + (lineIndex * lineHeight);
                    
                    // åº”ç”¨ç¼©è¿›
                    if (lineIndex === 2) currentX += 38;
                    if (lineIndex === 3) currentX += 40;
                    
                    let i = 0;
                    const safeLimit = line.length + 10;
                    let iterations = 0;
                    
                    while (i < line.length && iterations < safeLimit) {
                        iterations++;
                        
                        if (line.substr(i, 3) === '<b>') {
                            console.log(`ğŸ” æ‰¾åˆ°<b>æ ‡ç­¾åœ¨ä½ç½® ${i}`);
                            const endIndex = line.indexOf('</b>', i);
                            console.log(`ğŸ” æ‰¾åˆ°</b>æ ‡ç­¾åœ¨ä½ç½® ${endIndex}`);
                            if (endIndex > i) {
                                const boldText = line.substring(i + 3, endIndex);
                                console.log(`ğŸ” æå–ç²—ä½“æ–‡æœ¬: "${boldText}"`);
                                
                                // è®¾ç½®ç²—ä½“ï¼ˆä½¿ç”¨ä¸å½“å‰ä¸Šä¸‹æ–‡ç›¸åŒçš„é¢œè‰²ï¼‰
                                ctx.font = `bold ${fontSize}px "ç»å…¸éš¶å˜ç®€", Arial, sans-serif`;
                                ctx.fillStyle = textColor; // ç¡®ä¿ç²—ä½“ä½¿ç”¨æ­£ç¡®é¢œè‰²
                                
                                // å…ˆç»˜åˆ¶æè¾¹ï¼ˆå¦‚æœéœ€è¦ï¼‰ï¼Œå†ç»˜åˆ¶å¡«å……
                                if (useStroke) {
                                    ctx.strokeText(boldText, currentX, y);
                                }
                                ctx.fillText(boldText, currentX, y);
                                currentX += ctx.measureText(boldText).width;
                                
                                console.log(`ğŸ” ç²—ä½“æ–‡æœ¬å·²æ¸²æŸ“ï¼Œè·³è½¬åˆ°ä½ç½® ${endIndex + 4}`);
                                i = endIndex + 4;
                                continue;
                            } else {
                                console.log(`ğŸ” âš ï¸ æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„</b>æ ‡ç­¾`);
                            }
                        }
                        
                        // æ™®é€šå­—ç¬¦
                        const char = line[i];
                        console.log(`ğŸ” æ¸²æŸ“æ™®é€šå­—ç¬¦: "${char}" åœ¨ä½ç½® ${i}`);
                        ctx.font = `${fontSize}px "ç»å…¸éš¶å˜ç®€", Arial, sans-serif`;
                        ctx.fillStyle = textColor; // ç¡®ä¿æ™®é€šå­—ç¬¦ä½¿ç”¨æ­£ç¡®é¢œè‰²
                        
                        // å…ˆç»˜åˆ¶æè¾¹ï¼ˆå¦‚æœéœ€è¦ï¼‰ï¼Œå†ç»˜åˆ¶å¡«å……
                        if (useStroke) {
                            ctx.strokeText(char, currentX, y);
                        }
                        ctx.fillText(char, currentX, y);
                        currentX += ctx.measureText(char).width;
                        i++;
                    }
                });
                
                console.log(`âœ… ä¸­æ–‡æ–‡æœ¬æ¸²æŸ“æˆåŠŸ: ${lines.length}è¡Œ`);
                
            } catch (error) {
                console.error('âŒ ä¸­æ–‡æ–‡æœ¬æ¸²æŸ“å¤±è´¥:', error);
                throw error;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });

        // åˆå§‹åŒ–é¡µé¢
        async function initializePage() {
            if (window.location.search.includes('debug=true')) {
                console.log('ğŸš€ åˆå§‹åŒ–AIå¡ç‰Œç”Ÿæˆå™¨é¡µé¢');
            }
            
            // åˆå§‹åŒ–å›½é™…åŒ–ç³»ç»Ÿ
            await initializeI18n();
            
            // åˆå§‹åŒ–Sunwell
            initializeSunwell();
            
            // è®¾ç½®æ–‡ä»¶ä¸Šä¼ æ‹–æ‹½åŠŸèƒ½
            setupFileUpload();
            
            // æ˜¾ç¤ºåˆå§‹çŠ¶æ€
            showStatus(i18n.t('status.ready'), 'info');
        }

        // åˆå§‹åŒ–å›½é™…åŒ–ç³»ç»Ÿ
        async function initializeI18n() {
            try {
                // ç¡®ä¿i18nå¯¹è±¡å·²åŠ è½½
                if (typeof i18n === 'undefined') {
                    throw new Error('i18nå¯¹è±¡æœªå®šä¹‰ï¼Œè¯·æ£€æŸ¥i18n.jsæ˜¯å¦æ­£ç¡®åŠ è½½');
                }
                
                await i18n.init();
                
                // è®¾ç½®è¯­è¨€é€‰æ‹©å™¨çš„å½“å‰å€¼
                const languageSelect = document.getElementById('languageSelect');
                languageSelect.value = i18n.currentLanguage;
                
                // ç›‘å¬è¯­è¨€åˆ‡æ¢äº‹ä»¶
                i18n.on('languageChanged', function(language) {
                    console.log('è¯­è¨€å·²åˆ‡æ¢åˆ°:', language);
                    
                    // æ›´æ–°é¡µé¢ç¿»è¯‘
                    i18n.updatePageTranslations();
                    
                    // é‡æ–°åˆå§‹åŒ–Sunwellä»¥åº”ç”¨æ–°çš„å­—ä½“é…ç½®
                    if (sunwell) {
                        const getFontConfig = () => {
                            const currentLang = i18n.getCurrentLanguage();
                            
                            // å¤šè¯­è¨€å­—ä½“é…ç½®
                            const fontConfigs = {
                                'zh-CN': {
                                    titleFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "Arial Unicode MS", sans-serif'
                                },
                                'zh-TW': {
                                    titleFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft JhengHei", "PingFang TC", "Arial Unicode MS", sans-serif'
                                },
                                'ja-JP': {
                                    titleFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    bodyFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    gemFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", sans-serif'
                                },
                                'ko-KR': {
                                    titleFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    bodyFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    gemFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", sans-serif'
                                },
                                'en-US': {
                                    titleFont: 'Belwe, "Times New Roman", "Georgia", serif',
                                    bodyFont: '"Franklin Gothic Condensed", "Arial", "Helvetica", "Tahoma", sans-serif',
                                    gemFont: 'Belwe, "Times New Roman", "Georgia", serif'
                                }
                            };
                            
                            return fontConfigs[currentLang] || fontConfigs['en-US'];
                        };
                        
                        const fontConfig = getFontConfig();
                        
                        // æ ¹æ®è¯­è¨€è®¾ç½®å­—ä½“å¤§å° - è°ƒæ•´è‹±æ–‡å­—ä½“ä»¥é€‚é…å¡ç‰Œ
                        const currentLang = i18n.getCurrentLanguage();
                        let bodyFontSize = 28;  // ğŸ”§ ä¿®å¤ï¼šè‹±æ–‡ä½¿ç”¨28pxï¼Œé¿å…æ–‡æœ¬è¿‡å¤§ä¹±ç 
                        let bodyLineHeight = 32;  // ç›¸åº”è°ƒæ•´è¡Œé«˜
                        
                        // ğŸ”§ è¯­è¨€è·¯ç”±ç³»ç»Ÿï¼šè‹±æ–‡ä½¿ç”¨SunwellåŸç”Ÿæ–¹æ¡ˆï¼Œä¸­æ–‡/å…¶ä»–è¯­è¨€ä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†
                        const isEnglish = currentLang === 'en-US';
                        console.log(`ğŸ” è¯­è¨€è·¯ç”±æ£€æµ‹: ${currentLang}, æ˜¯å¦è‹±æ–‡: ${isEnglish}`);
                        
                        if (isEnglish) {
                            // ğŸ¯ è‹±æ–‡æ¨¡å¼ï¼šä½¿ç”¨ä¿®å¤åçš„é…ç½®ï¼Œç¡®ä¿æ–‡æœ¬æ¸²æŸ“æ­£ç¡®
                            console.log('ğŸ¨ è‹±æ–‡æ¨¡å¼ï¼šä½¿ç”¨ä¿®å¤åçš„Sunwellé…ç½®');
                            sunwell = new Sunwell({
                                assetFolder: './assets/',
                                // ğŸ”§ åº”ç”¨ä¿®å¤æ–¹æ¡ˆä¸­çš„å­—ä½“é…ç½®
                                titleFont: "Belwe, Arial, sans-serif",
                                bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                                bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                                bodyFontSize: 38,
                                bodyLineHeight: 40,
                                bodyFontOffset: {x: 0, y: 30}, // ä¿®å¤åçš„å‚ç›´ä½ç½®
                                drawTimeout: 20000,
                                debug: false
                            });
                        } else {
                            // ğŸ¯ ä¸­æ–‡/å…¶ä»–è¯­è¨€æ¨¡å¼ï¼šéšè—Sunwellæ–‡æœ¬ï¼Œä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†
                            console.log('ğŸ¨ ä¸­æ–‡/å…¶ä»–è¯­è¨€æ¨¡å¼ï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†æ–¹æ¡ˆ');
                            sunwell = new Sunwell({
                                titleFont: "Arial, sans-serif",
                                bodyFontRegular: "Arial, sans-serif",
                                bodyFontItalic: "Arial, sans-serif",  
                                bodyFontBold: "Arial, sans-serif",
                                bodyFontBoldItalic: "Arial, sans-serif",
                                bodyFontSize: 1,  // éšè—Sunwellæ–‡æœ¬
                                bodyLineHeight: 1,  
                                bodyFontOffset: {x: -9999, y: -9999},  // ç§»é™¤å±å¹•å¤–
                                gemFont: "Arial, sans-serif",
                                nameFont: "Arial, sans-serif",
                                assetFolder: './assets/',
                                drawTimeout: 20000,
                                debug: false
                            });
                        }
                        
                        console.log(`ğŸ”§ Sunwellè·¯ç”±é…ç½®å®Œæˆ: ${isEnglish ? 'è‹±æ–‡åŸç”Ÿæ¨¡å¼' : 'ä¸­æ–‡å¤–ç½®æ–‡æœ¬æ¡†æ¨¡å¼'}`);                        
                        
                        // é‡æ–°ç”Ÿæˆå¡ç‰Œä»¥åº”ç”¨æ–°è¯­è¨€å’Œå­—ä½“
                        if (currentCardData) {
                            renderCard(currentCardData);
                        }
                    }
                });
                
                console.log('âœ… å›½é™…åŒ–ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('âŒ å›½é™…åŒ–ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // è¯­è¨€åˆ‡æ¢å‡½æ•°
        async function changeLanguage(language) {
            try {
                const success = await i18n.switchLanguage(language);
                if (success) {
                    showStatus(i18n.t('status.languageChanged'), 'success');
                } else {
                    showStatus('è¯­è¨€åˆ‡æ¢å¤±è´¥', 'error');
                }
            } catch (error) {
                console.error('è¯­è¨€åˆ‡æ¢å¤±è´¥:', error);
                showStatus('è¯­è¨€åˆ‡æ¢å¤±è´¥', 'error');
            }
        }

        // åˆå§‹åŒ–Sunwellåº“
        function initializeSunwell() {
            try {
                if (window.location.search.includes('debug=true')) {
                    console.log('ğŸ¨ åˆå§‹åŒ–Sunwellæ¸²æŸ“å¼•æ“');
                }
                
                // ç­‰å¾…Sunwellåº“åŠ è½½å®Œæˆ
                const checkSunwell = setInterval(() => {
                    if (typeof Sunwell !== 'undefined') {
                        clearInterval(checkSunwell);
                        
                        // ğŸš¨ é‡æ–°ç¡®ä¿charså‡½æ•°åœ¨SunwellåŠ è½½åä»å¯ç”¨
                        if (typeof window.chars === 'undefined' || typeof chars === 'undefined') {
                            console.error('ğŸš¨ è­¦å‘Šï¼šSunwellåŠ è½½åcharså‡½æ•°ä¸¢å¤±ï¼é‡æ–°è®¾ç½®...');
                            // é‡æ–°è®¾ç½®charså‡½æ•°ï¼ˆä»ä¸Šé¢å¤åˆ¶ï¼‰
                            const charsFunc = function(text) {
                                if (!text || typeof text !== 'string') return [];
                                return Array.from(text);
                            };
                            charsFunc.category = function(char) {
                                if (!char || typeof char !== 'string') return 'P';
                                const code = char.codePointAt(0);
                                if (code >= 0x4E00 && code <= 0x9FFF) return 'Lo';
                                if (code >= 0x3400 && code <= 0x4DBF) return 'Lo';
                                if (code >= 0xF900 && code <= 0xFAFF) return 'Lo';
                                if ((code >= 0x41 && code <= 0x5A) || (code >= 0x61 && code <= 0x7A)) return 'L';
                                if (code >= 0x30 && code <= 0x39) return 'N';
                                if (/\s/.test(char)) return 'Z';
                                if (/[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š""''ï¼ˆï¼‰ã€ã€‘ã€Šã€‹]/.test(char)) return 'P';
                                return 'P';
                            };
                            
                            window.chars = charsFunc;
                            global.chars = charsFunc;
                            console.log('ğŸš¨ charså‡½æ•°é‡æ–°è®¾ç½®å®Œæˆ');
                        }
                        
                        // æ ¹æ®å½“å‰è¯­è¨€é€‰æ‹©åˆé€‚çš„å­—ä½“
                        const getFontConfig = () => {
                            const currentLang = i18n.getCurrentLanguage();
                            
                            // å¤šè¯­è¨€å­—ä½“é…ç½®
                            const fontConfigs = {
                                'zh-CN': {
                                    titleFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "WenQuanYi Micro Hei", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft YaHei", "PingFang SC", "Hiragino Sans GB", "Arial Unicode MS", sans-serif'
                                },
                                'zh-TW': {
                                    titleFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    bodyFont: '"Microsoft JhengHei", "PingFang TC", "Hiragino Sans CNS", "Apple LiGothic Medium", "Arial Unicode MS", sans-serif',
                                    gemFont: '"Microsoft JhengHei", "PingFang TC", "Arial Unicode MS", sans-serif'
                                },
                                'ja-JP': {
                                    titleFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    bodyFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", "Meiryo", "MS PGothic", sans-serif',
                                    gemFont: '"Hiragino Kaku Gothic ProN", "Hiragino Sans", "Yu Gothic Medium", sans-serif'
                                },
                                'ko-KR': {
                                    titleFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    bodyFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", "Source Han Sans KR", sans-serif',
                                    gemFont: '"Malgun Gothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", sans-serif'
                                },
                                'en-US': {
                                    titleFont: 'Belwe, "Times New Roman", "Georgia", serif',
                                    bodyFont: '"Franklin Gothic Condensed", "Arial", "Helvetica", "Tahoma", sans-serif',
                                    gemFont: 'Belwe, "Times New Roman", "Georgia", serif'
                                }
                            };
                            
                            return fontConfigs[currentLang] || fontConfigs['en-US'];
                        };
                        
                        const fontConfig = getFontConfig();
                        
                        // æ ¹æ®è¯­è¨€è®¾ç½®å­—ä½“å¤§å° - è°ƒæ•´è‹±æ–‡å­—ä½“ä»¥é€‚é…å¡ç‰Œ
                        const currentLang = i18n.getCurrentLanguage();
                        let bodyFontSize = 28;  // ğŸ”§ ä¿®å¤ï¼šè‹±æ–‡ä½¿ç”¨28pxï¼Œé¿å…æ–‡æœ¬è¿‡å¤§ä¹±ç 
                        let bodyLineHeight = 32;  // ç›¸åº”è°ƒæ•´è¡Œé«˜
                        
                        // ä¸ºæ—¥è¯­è®¾ç½®æ›´å¤§çš„å­—ä½“å¤§å°ä»¥æé«˜å¯è¯»æ€§
                        if (currentLang === 'ja-JP') {
                            bodyFontSize = 72;  // ä»48å¢å¤§åˆ°72
                            bodyLineHeight = 80;  // ç›¸åº”è°ƒæ•´è¡Œé«˜
                        }
                        
                        // æ ¹æ®è¯­è¨€è°ƒæ•´å­—ä½“åç§»é‡
                        let bodyFontOffset = {x: 0, y: 8};
                        if (currentLang === 'ja-JP') {
                            bodyFontOffset = {x: 0, y: 10}; // æ—¥è¯­å­—ä½“ç¨å¾®å‘ä¸‹åç§»ä»¥æ”¹å–„æ˜¾ç¤º
                        }
                        
                        // ğŸ”§ è¯­è¨€è·¯ç”±ç³»ç»Ÿ(ç¬¬äºŒå¤„)ï¼šè‹±æ–‡ä½¿ç”¨SunwellåŸç”Ÿæ–¹æ¡ˆï¼Œä¸­æ–‡/å…¶ä»–è¯­è¨€ä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†
                        const isEnglish = currentLang === 'en-US';
                        console.log(`ğŸ” è¯­è¨€è·¯ç”±æ£€æµ‹(ç¬¬äºŒå¤„): ${currentLang}, æ˜¯å¦è‹±æ–‡: ${isEnglish}`);
                        
                        if (isEnglish) {
                            // ğŸ¯ è‹±æ–‡æ¨¡å¼ï¼šä½¿ç”¨ä¿®å¤åçš„é…ç½®ï¼Œç¡®ä¿æ–‡æœ¬æ¸²æŸ“æ­£ç¡®
                            console.log('ğŸ¨ è‹±æ–‡æ¨¡å¼(ç¬¬äºŒå¤„)ï¼šä½¿ç”¨ä¿®å¤åçš„Sunwellé…ç½®');
                            sunwell = new Sunwell({
                                assetFolder: './assets/',
                                // ğŸ”§ åº”ç”¨ä¿®å¤æ–¹æ¡ˆä¸­çš„å­—ä½“é…ç½®
                                titleFont: "Belwe, Arial, sans-serif",
                                bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                                bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                                bodyFontSize: 38,
                                bodyLineHeight: 40,
                                bodyFontOffset: {x: 0, y: 30}, // ä¿®å¤åçš„å‚ç›´ä½ç½®
                                drawTimeout: 20000,
                                debug: false
                            });
                        } else {
                            // ğŸ¯ ä¸­æ–‡/å…¶ä»–è¯­è¨€æ¨¡å¼ï¼šéšè—Sunwellæ–‡æœ¬ï¼Œä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†
                            console.log('ğŸ¨ ä¸­æ–‡/å…¶ä»–è¯­è¨€æ¨¡å¼(ç¬¬äºŒå¤„)ï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†æ–¹æ¡ˆ');
                            sunwell = new Sunwell({
                                titleFont: "Arial, sans-serif",
                                bodyFontRegular: "Arial, sans-serif",
                                bodyFontItalic: "Arial, sans-serif",  
                                bodyFontBold: "Arial, sans-serif",
                                bodyFontBoldItalic: "Arial, sans-serif",
                                bodyFontSize: 1,  // éšè—Sunwellæ–‡æœ¬
                                bodyLineHeight: 1,  
                                bodyFontOffset: {x: -9999, y: -9999},  // ç§»é™¤å±å¹•å¤–
                                gemFont: "Arial, sans-serif",
                                nameFont: "Arial, sans-serif",
                                assetFolder: './assets/',
                                drawTimeout: 20000,
                                debug: false
                            });
                        }
                        
                        console.log(`ğŸ”§ Sunwellè·¯ç”±é…ç½®å®Œæˆ(ç¬¬äºŒå¤„): ${isEnglish ? 'è‹±æ–‡åŸç”Ÿæ¨¡å¼' : 'ä¸­æ–‡å¤–ç½®æ–‡æœ¬æ¡†æ¨¡å¼'}`);
                        
                        // Sunwellå·²é€šè¿‡æ„é€ å‡½æ•°é…ç½®ï¼Œæ— éœ€é¢å¤–è®¾ç½®
                        if (window.location.search.includes('debug=true')) {
                            console.log('âœ… Sunwellé…ç½®å®Œæˆ');
                            console.log('âœ… Sunwellåˆå§‹åŒ–æˆåŠŸ');
                        }
                        showStatus('Sunwellæ¸²æŸ“å¼•æ“å·²å°±ç»ª', 'success');
                    }
                }, 100);
                
                // è¶…æ—¶æ£€æŸ¥
                setTimeout(() => {
                    if (!sunwell) {
                        console.error('âŒ Sunwellåˆå§‹åŒ–è¶…æ—¶');
                        showStatus('æ¸²æŸ“å¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
                    }
                }, 10000);
                
            } catch (error) {
                console.error('âŒ Sunwellåˆå§‹åŒ–å¤±è´¥:', error);
                showStatus('æ¸²æŸ“å¼•æ“åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è®¾ç½®æ–‡ä»¶ä¸Šä¼ æ‹–æ‹½åŠŸèƒ½
        function setupFileUpload() {
            const fileUpload = document.querySelector('.file-upload-label');
            const fileInput = document.getElementById('cardImage');

            // æ‹–æ‹½äº‹ä»¶
            fileUpload.addEventListener('dragover', function(e) {
                e.preventDefault();
                fileUpload.classList.add('dragover');
            });

            fileUpload.addEventListener('dragleave', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
            });

            fileUpload.addEventListener('drop', function(e) {
                e.preventDefault();
                fileUpload.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    handleFileSelect(files[0]);
                }
            });

            // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFileSelect(e.target.files[0]);
                }
            });
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(file) {
            if (file && file.type.startsWith('image/')) {
                if (window.location.search.includes('debug=true')) {
                    console.log('ğŸ“ ç”¨æˆ·ä¸Šä¼ å›¾ç‰‡:', file.name);
                }
                
                // è¯»å–æ–‡ä»¶å¹¶è®¾ç½®uploadedImageå˜é‡
                const reader = new FileReader();
                reader.onload = function(e) {
                    uploadedImage = e.target.result;
                    if (window.location.search.includes('debug=true')) {
                        console.log('âœ… å›¾ç‰‡å·²è¯»å–å¹¶è®¾ç½®ä¸ºuploadedImage');
                    }
                    showStatus(`å·²é€‰æ‹©å›¾ç‰‡: ${file.name}ï¼Œå°†ä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡`, 'success');
                };
                reader.onerror = function() {
                    showStatus('å›¾ç‰‡è¯»å–å¤±è´¥ï¼Œè¯·é‡æ–°é€‰æ‹©', 'error');
                };
                reader.readAsDataURL(file);
            } else {
                showStatus('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶', 'error');
            }
        }

        // è®¾ç½®ç¤ºä¾‹æç¤ºè¯
        function setPrompt(prompt) {
            document.getElementById('cardPrompt').value = prompt;
            showStatus(i18n.t('status.promptSet'), 'info');
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const statusElement = document.getElementById('statusMessage');
            statusElement.textContent = message;
            statusElement.className = `status-message ${type}`;
            statusElement.style.display = 'block';
            
            // 3ç§’åè‡ªåŠ¨éšè—æˆåŠŸå’Œä¿¡æ¯æ¶ˆæ¯
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);
            }
        }
        
        // æ›´æ–°çŠ¶æ€çš„åˆ«åå‡½æ•°
        function updateStatus(message, type = 'info') {
            showStatus(message, type);
        }
        
        // è§£æAIç”Ÿæˆçš„å¡ç‰Œä¿¡æ¯
        function parseCardInfo(aiResponse) {
            if (window.location.search.includes('debug=true')) {
                console.log('ğŸ” å¼€å§‹è§£æAIå“åº”');
            }
            
            try {
                // å°è¯•è§£æJSONæ ¼å¼çš„å“åº”
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    if (window.location.search.includes('debug=true')) {
                        console.log('âœ… JSONè§£ææˆåŠŸ:', parsed);
                    }
                    return parsed;
                }
                
                // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼Œä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–ä¿¡æ¯
                const cardInfo = {
                    name: extractValue(aiResponse, ['åç§°', 'name', 'å¡ç‰Œåç§°', 'ã‚«ãƒ¼ãƒ‰å', 'åå‰']) || 'ç¥ç§˜ç”Ÿç‰©',
                    cost: parseInt(extractValue(aiResponse, ['è´¹ç”¨', 'cost', 'æ³•åŠ›å€¼', 'ã‚³ã‚¹ãƒˆ', 'ãƒãƒŠã‚³ã‚¹ãƒˆ'])) || 3,
                    attack: parseInt(extractValue(aiResponse, ['æ”»å‡»', 'attack', 'æ”»å‡»åŠ›', 'æ”»æ’ƒåŠ›', 'æ”»æ’ƒ'])) || 2,
                    health: parseInt(extractValue(aiResponse, ['ç”Ÿå‘½', 'health', 'ç”Ÿå‘½å€¼', 'ä½“åŠ›', 'ç”Ÿå‘½å€¤'])) || 3,
                    text: extractValue(aiResponse, ['æè¿°', 'description', 'æ•ˆæœ', 'text', 'èª¬æ˜', 'ãƒ†ã‚­ã‚¹ãƒˆ']) || '',
                    cardClass: extractValue(aiResponse, ['èŒä¸š', 'class', 'è‹±é›„èŒä¸š', 'ã‚¯ãƒ©ã‚¹', 'è·æ¥­']) || 'NEUTRAL',
                    race: extractValue(aiResponse, ['ç§æ—', 'race', 'ç”Ÿç‰©ç±»å‹', 'ç¨®æ—', 'ãƒ¬ãƒ¼ã‚¹']) || '',
                    rarity: extractValue(aiResponse, ['ç¨€æœ‰åº¦', 'rarity', 'ãƒ¬ã‚¢ãƒªãƒ†ã‚£', 'å¸Œå°‘åº¦']) || 'COMMON'
                };
                
                if (window.location.search.includes('debug=true')) {
                    console.log('âœ… è§£æç»“æœ:', cardInfo);
                }
                return cardInfo;
            } catch (error) {
                console.error('è§£æå¡ç‰Œä¿¡æ¯å¤±è´¥:', error);
                if (window.location.search.includes('debug=true')) {
                    console.log('âš ï¸ è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                }
                return {
                    name: 'ç¥ç§˜ç”Ÿç‰©',
                    cost: 3,
                    attack: 2,
                    health: 3,
                    text: 'ä¸€ä¸ªç¥ç§˜çš„ç”Ÿç‰©ã€‚',
                    cardClass: 'NEUTRAL',
                    race: '',
                    rarity: 'COMMON'
                };
            }
        }
        
        // æå–å€¼çš„è¾…åŠ©å‡½æ•°
        function extractValue(text, keys) {
            for (const key of keys) {
                const regex = new RegExp(`${key}[ï¼š:ï¼š]?\\s*([^\\n,ï¼Œ]+)`, 'i');
                const match = text.match(regex);
                if (match) {
                    return match[1].trim();
                }
            }
            return null;
        }

        // æ˜¾ç¤º/éšè—åŠ è½½çŠ¶æ€
        function showLoading(show, textKey = 'status.generating') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            const generateBtn = document.getElementById('generateBtn');
            
            if (show) {
                loading.classList.add('show');
                loadingText.textContent = i18n.t(textKey);
                generateBtn.disabled = true;
            } else {
                loading.classList.remove('show');
                generateBtn.disabled = false;
            }
        }

        // ä¸»è¦çš„å¡ç‰Œç”Ÿæˆå‡½æ•°
        async function generateCard() {
            const prompt = document.getElementById('cardPrompt').value.trim();
            const imageFile = document.getElementById('cardImage').files[0];
            
            if (!prompt) {
                showStatus(i18n.t('errors.noPrompt'), 'error');
                return;
            }
            
            if (!sunwell) {
                showStatus(i18n.t('errors.engineNotReady'), 'error');
                return;
            }
            
            try {
                showLoading(true, 'status.analyzingPrompt');
                if (window.location.search.includes('debug=true')) {
                    console.log('ğŸ¤– å¼€å§‹AIå¡ç‰Œç”Ÿæˆæµç¨‹');
                    console.log('ğŸ“ ç”¨æˆ·æç¤ºè¯:', prompt);
                }
                
                // æ­¥éª¤1: è§£æå¡ç‰Œå±æ€§
                showLoading(true, 'status.parsingAttributes');
                const cardAttributes = await generateCardAttributes(prompt);
                if (window.location.search.includes('debug=true')) {
                    console.log('ğŸ“Š è§£æçš„å¡ç‰Œå±æ€§:', cardAttributes);
                }
                
                // æ­¥éª¤2: ç”Ÿæˆæˆ–å¤„ç†å›¾ç‰‡
                let cardImageUrl = null;
                if (imageFile) {
                    showLoading(true, 'status.processingImage');
                    cardImageUrl = await processUploadedImage(imageFile);
                } else {
                    showLoading(true, 'status.generatingImage');
                    cardImageUrl = await generateCardImage(cardAttributes);
                }
                
                // æ­¥éª¤3: æ¸²æŸ“å¡ç‰Œ
                showLoading(true, 'status.renderingCard');
                await renderCard(cardAttributes, cardImageUrl);
                
                showLoading(false);
                showStatus(i18n.t('status.generateSuccess'), 'success');
                
            } catch (error) {
                console.error('âŒ å¡ç‰Œç”Ÿæˆå¤±è´¥:', error);
                showLoading(false);
                showStatus(i18n.t('errors.generateFailed') + ': ' + error.message, 'error');
            }
        }



        // ç”ŸæˆAIå¡ç‰Œçš„ä¸»å‡½æ•°
        async function generateAICard() {
            const prompt = document.getElementById('cardPrompt').value.trim();
            if (!prompt) {
                showStatus(i18n.t('errors.noPrompt'), 'error');
                return;
            }

            if (window.location.search.includes('debug=true')) {
                console.log('ğŸ¤– å¼€å§‹ç”ŸæˆAIå¡ç‰Œï¼Œæç¤ºè¯:', prompt);
            }
            showLoading(true);
            showStatus(i18n.t('status.generatingAI'), 'info');

            try {
                // 1. ç”Ÿæˆå¡ç‰Œå±æ€§
                const cardAttributes = await generateCardAttributes(prompt);
                
                // 2. ç”Ÿæˆæˆ–ä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡
                let imageUrl;
                if (uploadedImage) {
                    imageUrl = uploadedImage;
                } else {
                    imageUrl = await generateAIImage(cardAttributes.name || prompt);
                }
                
                // 3. æ¸²æŸ“å¡ç‰Œ
                await renderCard(cardAttributes, imageUrl);
                
                showStatus(i18n.t('status.aiGenerateComplete'), 'success');
            } catch (error) {
                console.error('ç”ŸæˆAIå¡ç‰Œå¤±è´¥:', error);

                showStatus(i18n.t('errors.generateFailed') + ': ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // ç”Ÿæˆå¡ç‰Œå±æ€§
        async function generateCardAttributes(prompt) {
            showStatus(i18n.t('status.analyzingAttributes'), 'info');
            
            // è·å–å½“å‰è¯­è¨€çš„ç³»ç»Ÿæç¤ºè¯
            const currentLanguage = i18n.getCurrentLanguage();
            const systemPrompt = CardPrompts.getCardPrompt(currentLanguage);

            try {
                // ğŸ”§ æ£€æŸ¥ç½‘ç»œè¿æ¥
                console.log('ğŸŒ å°è¯•è¿æ¥Gemini API...');
                
                const requestBody = {
                    contents: [{
                        parts: [{
                            text: systemPrompt + '\n\nç”¨æˆ·æè¿°: ' + prompt
                        }]
                    }]
                };
                
                // ğŸ”§ æ·»åŠ è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ—¶
                
                const response = await fetch(GEMINI_API_URL + '?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('APIå“åº”é”™è¯¯:', response.status, errorText);
                    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                console.log('âœ… APIå“åº”æˆåŠŸ:', data);
                
                const aiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                
                if (!aiResponse) {
                    throw new Error('APIè¿”å›ç©ºå“åº”');
                }
                
                const cardInfo = parseCardInfo(aiResponse);
                return cardInfo;
                
            } catch (error) {
                console.error('âŒ ç”Ÿæˆå¡ç‰Œå±æ€§å¤±è´¥:', error);
                
                // ğŸ”§ æä¾›å¤‡ç”¨æ–¹æ¡ˆï¼šæœ¬åœ°ç¤ºä¾‹å¡ç‰Œ
                if (error.name === 'AbortError') {
                    console.log('ğŸ”§ APIè¶…æ—¶ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨å¡ç‰Œ');
                    return generateFallbackCard(prompt, currentLanguage);
                } else if (error.message.includes('Failed to fetch')) {
                    console.log('ğŸ”§ ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨å¡ç‰Œ');
                    return generateFallbackCard(prompt, currentLanguage);
                } else {
                    throw new Error(i18n.t('errors.aiServiceUnavailable') + ': ' + error.message);
                }
            }
        }
        
        // ğŸ”§ å¤‡ç”¨å¡ç‰Œç”Ÿæˆå‡½æ•°
        function generateFallbackCard(prompt, language = 'ko-KR') {
            console.log('ğŸ¯ ç”Ÿæˆæœ¬åœ°å¤‡ç”¨å¡ç‰Œï¼Œè¯­è¨€:', language);
            
            // æ ¹æ®è¯­è¨€ç”Ÿæˆä¸åŒçš„ç¤ºä¾‹å¡ç‰Œ
            const fallbackCards = {
                'ko-KR': {
                    name: 'ì§€ì˜¥ì˜ ë°œí†±',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>ì „íˆ¬ì˜ í•¨ì„±</b>: ì  ì˜ì›…ì—ê²Œ 2ì˜ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤. ì´ í•˜ìˆ˜ì¸ì´ ì£½ìœ¼ë©´, ì  ì˜ì›…ì—ê²Œ 1ì˜ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'zh-CN': {
                    name: 'åœ°ç‹±çˆªç‰™',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>æˆ˜å¼</b>ï¼šå¯¹æ•Œæ–¹è‹±é›„é€ æˆ2ç‚¹ä¼¤å®³ã€‚è¯¥éšä»æ­»äº¡æ—¶ï¼Œå¯¹æ•Œæ–¹è‹±é›„é€ æˆ1ç‚¹ä¼¤å®³ã€‚',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'zh-TW': {
                    name: 'åœ°ç„çˆªç‰™',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>æˆ°å¼</b>ï¼šå°æ•µæ–¹è‹±é›„é€ æˆ2é»å‚·å®³ã€‚è©²éš¨å¾æ­»äº¡æ™‚ï¼Œå°æ•µæ–¹è‹±é›„é€ æˆ1é»å‚·å®³ã€‚',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'ja-JP': {
                    name: 'åœ°ç„ã®çˆªç‰™',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>é›„å«ã³</b>ï¼šæ•µãƒ’ãƒ¼ãƒ­ãƒ¼ã«2ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚ã“ã®ãƒŸãƒ‹ã‚ªãƒ³ãŒæ­»äº¡ã—ãŸæ™‚ã€æ•µãƒ’ãƒ¼ãƒ­ãƒ¼ã«1ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                },
                'en-US': {
                    name: 'Infernal Minion',
                    cost: 6,
                    attack: 5,
                    health: 6,
                    text: '<b>Battlecry:</b> Deal 2 damage to the enemy hero. <b>Deathrattle:</b> Deal 1 damage to the enemy hero.',
                    cardClass: 'WARLOCK',
                    rarity: 'EPIC',
                    race: 'DEMON'
                }
            };
            
            const fallbackCard = fallbackCards[language] || fallbackCards['en-US'];
            console.log('âœ… ç”Ÿæˆå¤‡ç”¨å¡ç‰Œ:', fallbackCard);
            showStatus(`ğŸ”§ ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ç¤ºä¾‹å¡ç‰Œ: ${fallbackCard.name}`, 'info');
            
            return fallbackCard;
        }

        // ç”ŸæˆAIå›¾ç‰‡çš„å‡½æ•°ï¼ˆä½¿ç”¨Geminiå›¾ç‰‡ç”Ÿæˆæ¨¡å‹ï¼‰
        async function generateAIImage(prompt) {
            updateStatus(i18n.t('status.generatingAIImage'), 'info');
            
            try {
                // ä½¿ç”¨prompts.jsç”ŸæˆåŸç”»æç¤ºè¯ï¼ˆä¸åŒ…å«å¡ç‰Œæ ·å¼ï¼‰
                const imagePrompt = ImagePrompts.generateArtworkPrompt(prompt, '');
                
                if (window.location.search.includes('debug=true')) {
                    console.log('ğŸ¨ å›¾ç‰‡ç”Ÿæˆæç¤ºè¯:', imagePrompt);
                }
                
                // è°ƒç”¨Geminiå›¾ç‰‡ç”ŸæˆAPI
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: imagePrompt
                            }]
                        }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE']
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Geminiå›¾ç‰‡ç”ŸæˆAPIè¯·æ±‚å¤±è´¥: ${response.status}`);
                }
                
                const data = await response.json();
                if (window.location.search.includes('debug=true')) {
                     console.log('ğŸ–¼ï¸ Geminiå›¾ç‰‡ç”ŸæˆAPIå“åº”:', data);
                 }
                
                // æŸ¥æ‰¾å›¾ç‰‡æ•°æ®
                let imageData = null;
                const candidate = data.candidates?.[0];
                if (candidate && candidate.content && candidate.content.parts) {
                    for (const part of candidate.content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            imageData = part.inlineData.data;
                            break;
                        }
                    }
                }
                
                if (!imageData) {
                    throw new Error('æœªæ‰¾åˆ°ç”Ÿæˆçš„å›¾ç‰‡æ•°æ®');
                }
                
                // å°†base64æ•°æ®è½¬æ¢ä¸ºdata URL
                const imageUrl = `data:image/png;base64,${imageData}`;
                if (window.location.search.includes('debug=true')) {
                     console.log('ğŸ–¼ï¸ ç”Ÿæˆçš„å›¾ç‰‡Data URLé•¿åº¦:', imageUrl.length);
                 }
                
                // éªŒè¯å›¾ç‰‡æ˜¯å¦æœ‰æ•ˆ
                const img = new Image();
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        if (window.location.search.includes('debug=true')) {
                            console.log('âœ… Geminiç”Ÿæˆçš„AIå›¾ç‰‡åŠ è½½æˆåŠŸ');
                        }
                        updateStatus(i18n.t('status.aiImageComplete'), 'success');
                        resolve(imageUrl);
                    };
                    img.onerror = () => {
                        if (window.location.search.includes('debug=true')) {
                            console.log('âŒ Geminiç”Ÿæˆçš„AIå›¾ç‰‡åŠ è½½å¤±è´¥');
                        }
                        updateStatus(i18n.t('errors.aiImageLoadFailed'), 'error');
                        reject(new Error(i18n.t('errors.invalidImage')));
                    };
                    img.src = imageUrl;
                });
                
            } catch (error) {
                console.error('âŒ ç”ŸæˆAIå›¾ç‰‡å¤±è´¥:', error);
                updateStatus(i18n.t('errors.aiImageGenerateFailed') + ': ' + error.message, 'error');
                return null;
            }
        }
        
        // ç”Ÿæˆå¡ç‰Œå›¾ç‰‡ï¼ˆä½¿ç”¨Geminiå›¾ç‰‡ç”Ÿæˆæ¨¡å‹ï¼‰
        async function generateCardImage(cardAttributes) {
            if (window.location.search.includes('debug=true')) {
                console.log('ğŸ¨ ä½¿ç”¨Geminiç”Ÿæˆç‚‰çŸ³ä¼ è¯´é£æ ¼å›¾ç‰‡');
            }
            
            // ä½¿ç”¨prompts.jsæ ¹æ®å¡ç‰Œç±»å‹ç”ŸæˆåŸç”»æç¤ºè¯
            const imagePrompt = ImagePrompts.getPromptByType(cardAttributes.name, cardAttributes.text, cardAttributes.type || 'MINION');
            
            try {
                // è°ƒç”¨Geminiå›¾ç‰‡ç”ŸæˆAPI
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=' + GEMINI_API_KEY, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: imagePrompt
                            }]
                        }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE']
                        }
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Geminiå›¾ç‰‡ç”ŸæˆAPIè¯·æ±‚å¤±è´¥: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('ğŸ–¼ï¸ Geminiå›¾ç‰‡ç”ŸæˆAPIå“åº”:', data);
                
                // æŸ¥æ‰¾å›¾ç‰‡æ•°æ®
                let imageData = null;
                const candidate = data.candidates?.[0];
                if (candidate && candidate.content && candidate.content.parts) {
                    for (const part of candidate.content.parts) {
                        if (part.inlineData && part.inlineData.data) {
                            imageData = part.inlineData.data;
                            break;
                        }
                    }
                }
                
                if (!imageData) {
                    throw new Error('æœªæ‰¾åˆ°ç”Ÿæˆçš„å›¾ç‰‡æ•°æ®');
                }
                
                // å°†base64æ•°æ®è½¬æ¢ä¸ºdata URL
                const imageUrl = `data:image/png;base64,${imageData}`;
                console.log('ğŸ–¼ï¸ ç”Ÿæˆçš„å›¾ç‰‡Data URLé•¿åº¦:', imageUrl.length);
                return imageUrl;
                
            } catch (error) {
                console.error('âŒ Geminiå›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
                // è¿”å›é»˜è®¤å›¾ç‰‡URL
                return './assets/mPreload.jpg';
            }
        }

        // å¤„ç†ä¸Šä¼ çš„å›¾ç‰‡
        async function processUploadedImage(file) {
            if (window.location.search.includes('debug=true')) {
                console.log('ğŸ“ å¤„ç†ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡');
            }
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    if (window.location.search.includes('debug=true')) {
                        console.log('âœ… å›¾ç‰‡è¯»å–æˆåŠŸ');
                    }
                    resolve(e.target.result);
                };
                reader.onerror = function() {
                    reject(new Error(i18n.t('errors.imageReadFailed')));
                };
                reader.readAsDataURL(file);
            });
        }

        // æ¸²æŸ“å¡ç‰Œ
        async function renderCard(cardAttributes, imageUrl) {
            showStatus(i18n.t('status.renderingCard'), 'info');
            
            // ğŸ¯ å…³é”®ä¿®å¤ï¼šåŸºäºå¡ç‰Œæ–‡æœ¬å†…å®¹æ£€æµ‹è¯­è¨€ï¼Œè€Œä¸æ˜¯ç•Œé¢è¯­è¨€
            let cardText = cardAttributes.text || '';
            
            // ğŸ”§ æ”¹è¿›çš„è¯­è¨€æ£€æµ‹ï¼šåŒºåˆ†è‹±æ–‡å’Œæ‰€æœ‰å…¶ä»–è¯­è¨€ï¼ˆä¸­æ—¥éŸ©ç­‰ï¼‰
            function detectCardLanguage(text) {
                if (!text) return 'english';
                
                // æ£€æµ‹ä¸­æ–‡å­—ç¬¦ï¼ˆç®€ä½“ã€ç¹ä½“ï¼‰
                if (/[\u4e00-\u9fff]/.test(text)) return 'chinese';
                
                // æ£€æµ‹æ—¥æ–‡å­—ç¬¦ï¼ˆå¹³å‡åã€ç‰‡å‡åã€æ±‰å­—ï¼‰  
                if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'japanese';
                
                // æ£€æµ‹éŸ©æ–‡å­—ç¬¦
                if (/[\uac00-\ud7af]/.test(text)) return 'korean';
                
                // é»˜è®¤ä¸ºè‹±æ–‡
                return 'english';
            }
            
            const cardLanguage = detectCardLanguage(cardText);
            const isEnglishCard = (cardLanguage === 'english');
            
            console.log('ğŸ” åŸå§‹æ–‡æœ¬:', cardText);
            console.log('ğŸ” å¡ç‰Œå†…å®¹è¯­è¨€æ£€æµ‹:', cardLanguage, isEnglishCard ? '(è‹±æ–‡)' : '(éè‹±æ–‡)');
            
            // ğŸ”§ é‡è¦ï¼šåŸºäºå¡ç‰Œå†…å®¹è¯­è¨€é‡æ–°é…ç½®Sunwellï¼Œç¡®ä¿è¯­è¨€è·¯ç”±ä¸€è‡´æ€§
            console.log('ğŸ›¤ï¸ åŸºäºå¡ç‰Œå†…å®¹é‡æ–°é…ç½®Sunwellè·¯ç”±');
            if (isEnglishCard) {
                // ğŸ¯ è‹±æ–‡å†…å®¹ï¼šä½¿ç”¨ä¿®å¤åçš„Sunwellé…ç½®
                console.log('ğŸ¨ è‹±æ–‡å†…å®¹ï¼šé‡æ–°é…ç½®Sunwellä¸ºä¿®å¤åé…ç½®');
                sunwell = new Sunwell({
                    assetFolder: './assets/',
                    // ğŸ”§ åº”ç”¨ä¿®å¤æ–¹æ¡ˆä¸­çš„å­—ä½“é…ç½®
                    titleFont: "Belwe, Arial, sans-serif",
                    bodyFontRegular: "Franklin Gothic Condensed, Arial, sans-serif", 
                    bodyFontBold: "Franklin Gothic Condensed, Arial, sans-serif",
                    bodyFontSize: 38,
                    bodyLineHeight: 40,
                    bodyFontOffset: {x: 0, y: 30}, // ä¿®å¤åçš„å‚ç›´ä½ç½®
                    drawTimeout: 20000,
                    debug: false
                });
            } else {
                // ğŸ¯ ä¸­æ–‡å†…å®¹ï¼šé…ç½®Sunwelléšè—æ–‡æœ¬ï¼Œä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†
                console.log('ğŸ¨ ä¸­æ–‡å†…å®¹ï¼šé‡æ–°é…ç½®Sunwellä¸ºå¤–ç½®æ–‡æœ¬æ¡†æ¨¡å¼');
                sunwell = new Sunwell({
                    titleFont: "Arial, sans-serif",
                    bodyFontRegular: "Arial, sans-serif",
                    bodyFontItalic: "Arial, sans-serif",  
                    bodyFontBold: "Arial, sans-serif",
                    bodyFontBoldItalic: "Arial, sans-serif",
                    bodyFontSize: 1,  // éšè—Sunwellæ–‡æœ¬
                    bodyLineHeight: 1,  
                    bodyFontOffset: {x: -9999, y: -9999},  // ç§»é™¤å±å¹•å¤–
                    gemFont: "Arial, sans-serif",
                    nameFont: "Arial, sans-serif",
                    assetFolder: './assets/',
                    drawTimeout: 20000,
                    debug: false
                });
            }
            
            // ğŸ›¤ï¸ ç»Ÿä¸€å…³é”®è¯å¤„ç†ï¼šæ‰€æœ‰è¯­è¨€éƒ½éœ€è¦å¤„ç†å…³é”®è¯åŠ ç²—  
            if (cardText) {
                console.log(`ğŸ¨ ${cardLanguage}å¡ç‰Œï¼šå¤„ç†å…³é”®è¯åŠ ç²—`);
                console.log('ğŸ” å¤„ç†å‰æ–‡æœ¬:', cardText);
                
                // ğŸ”§ ç»Ÿä¸€å¤„ç†æ‰€æœ‰è¯­è¨€çš„å…³é”®è¯åŠ ç²—ï¼ˆä¸­è‹±æ—¥éŸ©ï¼‰
                const processedResult = safeProcessKeywords(cardText);
                cardText = processedResult.processedText;
                
                console.log('ğŸ” å¤„ç†åæ–‡æœ¬:', cardText);
                console.log('ğŸ” æ‰¾åˆ°çš„å…³é”®è¯:', processedResult.foundKeywords);
                
                if (isEnglishCard) {
                    // ğŸ¯ è‹±æ–‡å¡ç‰Œï¼šäº¤ç»™SunwellåŸè£…BodyTextç»„ä»¶å¤„ç†<b>æ ‡ç­¾
                    console.log('ğŸ¨ è‹±æ–‡å¡ç‰Œï¼šäº¤ç»™SunwellåŸè£…BodyTextç»„ä»¶æ¸²æŸ“');
                } else {
                    // ğŸ¯ éè‹±æ–‡å¡ç‰Œï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†è‡ªå®šä¹‰æ¸²æŸ“æ–¹æ¡ˆ
                    console.log(`ğŸ¨ ${cardLanguage}å¡ç‰Œï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†è‡ªå®šä¹‰æ¸²æŸ“æ–¹æ¡ˆ`);
                }
            }
            
            // æ„å»ºå¡ç‰Œæ•°æ®
            const cardData = {
                id: 'AI_' + Date.now(),
                name: cardAttributes.name,
                text: cardText, // ä½¿ç”¨å¤„ç†åçš„æ–‡æœ¬
                cost: cardAttributes.cost,
                attack: cardAttributes.attack,
                health: cardAttributes.health,
                cardClass: cardAttributes.cardClass,
                rarity: cardAttributes.rarity,
                type: 'MINION',
                race: cardAttributes.race || '',
                set: 'EXPERT1',
                collectible: true,
                texture: imageUrl,
                collectionText: cardText, // ä½¿ç”¨å¤„ç†åçš„æ–‡æœ¬
                flavor: '',
                elite: cardAttributes.rarity === 'LEGENDARY',
                silenced: false,
                hideStats: false,
                costsHealth: false,
                armor: 0
            };
            

            currentCardData = cardData;
            
            // ä½¿ç”¨Sunwellæ¸²æŸ“
            const canvas = document.getElementById('cardCanvas');
            if (!canvas) {
                throw new Error(i18n.t('errors.canvasNotFound'));
            }
            
            const isPremium = (cardData.rarity === 'LEGENDARY' || cardData.rarity === 'EPIC');
            
            console.log('ğŸ” ä¼ ç»™Sunwellçš„å¡ç‰Œæ•°æ®:', cardData);
            console.log('ğŸ” ç‰¹åˆ«æ˜¯æ–‡æœ¬å­—æ®µ:', cardData.text);
            
            // å¢å¼ºçš„è¶…æ—¶å’Œé”™è¯¯å¤„ç†
            let isCompleted = false;
            const timeoutId = setTimeout(() => {
                if (!isCompleted) {
                    showStatus('å¡ç‰Œç”Ÿæˆè¶…æ—¶ï¼Œè¯·æ£€æŸ¥æ–‡æœ¬å†…å®¹æˆ–é‡è¯•', 'error');
                    // æ˜¾ç¤ºé”™è¯¯æç¤º
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '20px Arial';
                    ctx.fillText('æ¸²æŸ“è¶…æ—¶ - è¯·æ£€æŸ¥æ–‡æœ¬åé‡è¯•', 20, 100);
                }
            }, 20000);
            
            try {
                const card = sunwell.createCard(
                    cardData,
                    400,
                    isPremium,
                    canvas,
                    function(renderedCanvas) {
                        isCompleted = true;
                        clearTimeout(timeoutId);
                        
                        console.log('å¡ç‰ŒåŸºç¡€æ¸²æŸ“å®Œæˆ');
                        
                        try {
                            // ğŸ”§ å…³é”®ä¿®å¤ï¼šä¸ºè‹±æ–‡æ¨¡å¼ä¿ç•™åŸå§‹æ–‡æœ¬ï¼Œä¸ºä¸­æ–‡æ¨¡å¼ä½¿ç”¨å¤„ç†åæ–‡æœ¬
                            const originalText = cardData.text;
                            
                            if (renderedCanvas && originalText && originalText.trim()) {
                                // ğŸ¯ è¯­è¨€æ£€æµ‹ï¼šåœ¨ä½¿ç”¨å‰å…ˆå®šä¹‰ï¼ˆä¸ä¸Šé¢ä¿æŒä¸€è‡´ï¼‰
                                function detectTextLanguage(text) {
                                    if (!text) return 'english';
                                    
                                    // æ£€æµ‹ä¸­æ–‡å­—ç¬¦ï¼ˆç®€ä½“ã€ç¹ä½“ï¼‰
                                    if (/[\u4e00-\u9fff]/.test(text)) return 'chinese';
                                    
                                    // æ£€æµ‹æ—¥æ–‡å­—ç¬¦ï¼ˆå¹³å‡åã€ç‰‡å‡åã€æ±‰å­—ï¼‰  
                                    if (/[\u3040-\u309f\u30a0-\u30ff]/.test(text)) return 'japanese';
                                    
                                    // æ£€æµ‹éŸ©æ–‡å­—ç¬¦
                                    if (/[\uac00-\ud7af]/.test(text)) return 'korean';
                                    
                                    // é»˜è®¤ä¸ºè‹±æ–‡
                                    return 'english';
                                }
                                
                                const detectedLanguage = detectTextLanguage(originalText);
                                const isNonEnglish = (detectedLanguage !== 'english');
                                console.log(`ğŸ›¤ï¸ è¯­è¨€è·¯ç”±æ£€æµ‹: ${detectedLanguage} - "${originalText}"`);
                                
                                if (isNonEnglish) {
                                    // ğŸ¯ éè‹±æ–‡å¡ç‰Œï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†è‡ªå®šä¹‰æ¸²æŸ“ç³»ç»Ÿ
                                    console.log(`ğŸ¨ ${detectedLanguage}å¡ç‰Œï¼šä½¿ç”¨å¤–ç½®æ–‡æœ¬æ¡†è‡ªå®šä¹‰æ¸²æŸ“ç³»ç»Ÿ`);
                                    
                                    // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿éŸ©è¯­ç­‰éè‹±æ–‡æ–‡æœ¬è¿›è¡Œå…³é”®è¯å¤„ç†
                                    console.log(`ğŸ” ${detectedLanguage}æ–‡æœ¬å…³é”®è¯å¤„ç†å‰: "${originalText}"`);
                                    const keywordResult = safeProcessKeywords(originalText);
                                    const processedText = keywordResult.processedText;
                                    console.log(`ğŸ” ${detectedLanguage}æ–‡æœ¬å…³é”®è¯å¤„ç†å: "${processedText}"`);
                                    console.log(`ğŸ” æ‰¾åˆ°çš„${detectedLanguage}å…³é”®è¯:`, keywordResult.foundKeywords);
                                    const textLength = processedText.length;
                                    
                                    // æ™ºèƒ½å­—ä½“é€‰æ‹©ï¼ˆéŸ©è¯­ä¼˜åŒ–ï¼‰
                                    let fontSize = 20;
                                    
                                    // æ£€æµ‹æ˜¯å¦ä¸ºéŸ©è¯­æ–‡æœ¬å¹¶è°ƒæ•´å­—ä½“å¤§å°
                                    const isKoreanText = /[ê°€-í¯]/.test(originalText);
                                    
                                    if (isKoreanText) {
                                        // éŸ©è¯­å­—ä½“ä¼˜åŒ–ï¼šå¹³è¡¡æ¸…æ™°åº¦å’Œè¾¹æ¡†é™åˆ¶
                                        if (textLength <= 15) fontSize = 22;  // é€‚ä¸­å¢åŠ 
                                        else if (textLength <= 30) fontSize = 21;  // é€‚ä¸­å¢åŠ 
                                        else if (textLength <= 50) fontSize = 20;  // é€‚ä¸­å¢åŠ 
                                        else fontSize = 19;  // é•¿æ–‡æœ¬ä¿æŒç´§å‡‘
                                        console.log(`ğŸ“ éŸ©è¯­å­—ä½“è°ƒæ•´: ${fontSize}px (åŸå§‹é•¿åº¦: ${textLength})`);
                                    } else {
                                        // ééŸ©è¯­æ–‡æœ¬ä½¿ç”¨åŸæœ‰é€»è¾‘
                                        if (textLength <= 15) fontSize = 23;
                                        else if (textLength <= 30) fontSize = 21;
                                        else if (textLength <= 50) fontSize = 19;
                                    }
                                    
                                    // ğŸ”§ ä½¿ç”¨å®é™…æµ‹é‡çš„æ–‡æœ¬æ¡†å®½åº¦ï¼ˆç‚‰çŸ³å¡ç‰Œæ–‡æœ¬åŒºåŸŸçº¦215pxï¼‰
                                    const lines = safeTextSplit(processedText, 215, fontSize);
                                    
                                    const textConfig = {
                                        text: originalText,
                                        processedText: processedText,
                                        fontSize: fontSize,
                                        lines: lines,
                                        isPremium: isPremium
                                    };
                                    
                                    safeRenderChineseText(renderedCanvas, textConfig);
                                    
                                    const colorInfo = isPremium ? 'ç™½è‰²æ–‡å­—(é‡‘è‰²)' : 'é»‘è‰²æ–‡å­—(æ™®é€š)';
                                    showStatus(`ä¸­æ–‡å¡ç‰Œç”ŸæˆæˆåŠŸï¼${fontSize}pxå­—ä½“ï¼Œ${lines.length}è¡Œï¼Œ${colorInfo}`, 'success');
                                    
                                } else {
                                    // ğŸ¯ è‹±æ–‡å¡ç‰Œï¼šå®Œå…¨ç”±SunwellåŸç”Ÿç³»ç»Ÿå¤„ç†ï¼Œä¸åšä»»ä½•è‡ªå®šä¹‰æ¸²æŸ“
                                    console.log(`ğŸ¨ ${detectedLanguage}å¡ç‰Œï¼šå®Œå…¨è·³è¿‡å¤–ç½®æ–‡æœ¬æ¡†ï¼Œç”±SunwellåŸç”Ÿç³»ç»Ÿå¤„ç†æ‰€æœ‰å†…å®¹`);
                                    console.log(`ğŸ” ${detectedLanguage}æ–‡æœ¬äº¤ç»™SunwellåŸç”Ÿå¤„ç†: "${originalText}"`);
                                    
                                    // è‹±æ–‡å®Œå…¨ä¸è¿›è¡Œä»»ä½•è‡ªå®šä¹‰æ–‡æœ¬æ¸²æŸ“ï¼Œè®©SunwellåŸç”Ÿå¤„ç†æ‰€æœ‰å†…å®¹
                                    // åŒ…æ‹¬ï¼šå­—ä½“å¤§å°ã€è¡Œé«˜ã€æ¢è¡Œã€å…³é”®è¯åŠ ç²—ã€æ–‡å­—ä½ç½®ç­‰
                                    const colorInfo = isPremium ? 'ç™½è‰²æ–‡å­—(é‡‘è‰²)' : 'é»‘è‰²æ–‡å­—(æ™®é€š)';
                                    showStatus(`è‹±æ–‡å¡ç‰Œç”ŸæˆæˆåŠŸï¼ä½¿ç”¨SunwellåŸç”Ÿæ–¹æ¡ˆï¼Œ${colorInfo}`, 'success');
                                }
                                
                                // ğŸ”§ ä¿®å¤ï¼šä¸å†éœ€è¦æ‰‹åŠ¨æ¸²æŸ“ä¸­æ–‡åç§°ï¼ŒSunwellå·²ç›´æ¥æ¸²æŸ“
                                console.log(`âœ… å¡ç‰Œåç§°ç”±Sunwellç›´æ¥æ¸²æŸ“: "${cardData.name}"`);
                            } else {
                                showStatus(i18n.t('status.renderComplete'), 'success');
                            }
                        } catch (textError) {
                            console.error('âŒ ä¸­æ–‡æ–‡æœ¬æ¸²æŸ“å¤±è´¥:', textError);
                            showStatus(`ä¸­æ–‡æ–‡æœ¬æ¸²æŸ“å¤±è´¥: ${textError.message}`, 'error');
                        }
                    }
                );
            } catch (error) {
                clearTimeout(timeoutId);
                console.error('æ¸²æŸ“å¡ç‰Œå¤±è´¥:', error);

                throw new Error(i18n.t('errors.renderFailed') + ': ' + error.message);
            }
        }

        // æ˜¾ç¤ºå¡ç‰Œä¿¡æ¯
        function displayCardInfo(cardData) {
            const cardInfo = document.getElementById('cardInfo');
            
            // è·å–å›½é™…åŒ–ç¿»è¯‘
            const getClassTranslation = (className) => {
                if (!className) return i18n.t('cardInfo.none');
                return i18n.t(`cardClasses.${className.toLowerCase()}`) || className;
            };
            
            const getRaceTranslation = (raceName) => {
                if (!raceName) return i18n.t('cardInfo.none');
                return i18n.t(`cardRaces.${raceName.toLowerCase()}`) || raceName;
            };
            
            const getRarityTranslation = (rarityName) => {
                if (!rarityName) return i18n.t('cardInfo.none');
                return i18n.t(`cardRarities.${rarityName.toLowerCase()}`) || rarityName;
            };
            
            cardInfo.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; color: #333;">ğŸ“‹ ${i18n.t('cardInfo.title')}</h4>
                    <div><strong>${i18n.t('cardInfo.name')}:</strong> ${cardData.name}</div>
                    <div><strong>${i18n.t('cardInfo.cost')}:</strong> ${cardData.cost}</div>
                    <div><strong>${i18n.t('cardInfo.attack')}:</strong> ${cardData.attack}</div>
                    <div><strong>${i18n.t('cardInfo.health')}:</strong> ${cardData.health}</div>
                    <div><strong>${i18n.t('cardInfo.class')}:</strong> ${getClassTranslation(cardData.cardClass || cardData.playerClass)}</div>
                    <div><strong>${i18n.t('cardInfo.race')}:</strong> ${getRaceTranslation(cardData.race)}</div>
                    <div><strong>${i18n.t('cardInfo.rarity')}:</strong> ${getRarityTranslation(cardData.rarity)}</div>
                    <div style="margin-top: 10px;"><strong>${i18n.t('cardInfo.description')}:</strong> ${cardData.text || cardData.description}</div>
                </div>
            `;
        }

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', function(e) {
            console.error('âŒ é¡µé¢é”™è¯¯:', e.error);
            showStatus(i18n.t('errors.pageError'), 'error');
        });

        // è°ƒè¯•ä¿¡æ¯ - é™é»˜æ¨¡å¼
        if (window.location.search.includes('debug=true')) {
            console.log('ğŸ® AIç‚‰çŸ³ä¼ è¯´å¡ç‰Œç”Ÿæˆå™¨å·²åŠ è½½');
            console.log('ğŸ”‘ Gemini API Keyå·²é…ç½®');
        }
    </script>
</body>
</html>